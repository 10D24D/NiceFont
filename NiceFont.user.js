// ==UserScript==
// @name         NiceFont (è€è§†å­—ä½“)
// @name:zh-CN    NiceFont (è€è§†å­—ä½“)
// @name:zh-TW    NiceFontï¼ˆè€è¦–å­—é«”ï¼‰
// @name:en       NiceFont
// @name:ko       NiceFont (ì¢‹ì€ ê¸€ê¼´)
// @name:ja       NiceFont (ã„ã„ãƒ•ã‚©ãƒ³ãƒˆ)
// @name:ru       NiceFont (Ğ¥Ğ¾Ñ€Ğ¾ÑˆĞ¸Ğ¹ ÑˆÑ€Ğ¸Ñ„Ñ‚)
// @name:fr       NiceFont (Police agrÃ©able)
// @name:de       NiceFont (SchÃ¶ne Schrift)
// @name:es       NiceFont (Fuente agradable)
// @name:pt       NiceFont (Fonte agradÃ¡vel)
// @version      3.2
// @author       DD1024z
// @description  NiceFont: æ˜¯ä¸€æ¬¾ä¼˜åŒ–ç½‘é¡µå­—ä½“æ˜¾ç¤ºçš„å·¥å…·ï¼Œè®©æµè§ˆæ›´æ¸…æ™°ã€èˆ’é€‚ï¼â€œçœŸæ­£è°ƒæ•´å­—ä½“ï¼Œè€Œéé¡µé¢ç¼©æ”¾ï¼Œæ‹’ç»å°†å°±â€ï¼å¯ç›´æ¥ä¿®æ”¹ç½‘é¡µçš„å­—ä½“å¤§å°ä¸é£æ ¼ï¼Œä¿å­˜ä½ çš„å­—ä½“è®¾ç½®ï¼Œè½»æ¾åº”ç”¨åˆ°æ¯ä¸ªç½‘é¡µï¼Œæ”¯æŒé¦–æ¬¡ã€å®šæ—¶æˆ–åŠ¨æ€è°ƒæ•´å­—ä½“ï¼Œé€‚é…å­åŸŸåã€æ•´ç«™æˆ–å…¨å±€è®¾ç½®ï¼Œå‡ ä¹å…¼å®¹æ‰€æœ‰ç½‘ç«™ï¼
// @description:zh-CN  NiceFont: æ˜¯ä¸€æ¬¾ä¼˜åŒ–ç½‘é¡µå­—ä½“æ˜¾ç¤ºçš„å·¥å…·ï¼Œè®©æµè§ˆæ›´æ¸…æ™°ã€èˆ’é€‚ï¼â€œçœŸæ­£è°ƒæ•´å­—ä½“ï¼Œè€Œéé¡µé¢ç¼©æ”¾ï¼Œæ‹’ç»å°†å°±â€ï¼å¯ç›´æ¥ä¿®æ”¹ç½‘é¡µçš„å­—ä½“å¤§å°ä¸é£æ ¼ï¼Œä¿å­˜ä½ çš„å­—ä½“è®¾ç½®ï¼Œè½»æ¾åº”ç”¨åˆ°æ¯ä¸ªç½‘é¡µï¼Œæ”¯æŒé¦–æ¬¡ã€å®šæ—¶æˆ–åŠ¨æ€è°ƒæ•´å­—ä½“ï¼Œé€‚é…å­åŸŸåã€æ•´ç«™æˆ–å…¨å±€è®¾ç½®ï¼Œå‡ ä¹å…¼å®¹æ‰€æœ‰ç½‘ç«™ï¼
// @description:zh-TW  NiceFontï¼šå„ªåŒ–ç¶²é å­—é«”é¡¯ç¤ºçš„å·¥å…·ï¼Œç€è¦½æ›´æ¸…æ™°ã€èˆ’é©ï¼ã€ŒçœŸæ­£èª¿æ•´å­—é«”ï¼Œéé é¢ç¸®æ”¾ï¼Œæ‹’çµ•å°‡å°±ã€ï¼ç›´æ¥ä¿®æ”¹å­—é«”å¤§å°èˆ‡é¢¨æ ¼ï¼Œå„²å­˜è¨­å®šï¼Œè¼•é¬†æ‡‰ç”¨æ–¼å„ç¶²é ï¼Œæ”¯æ´é¦–æ¬¡ã€å®šæ™‚æˆ–å‹•æ…‹èª¿æ•´ï¼Œé©é…å­åŸŸåæˆ–å…¨å±€è¨­å®šï¼Œå¹¾ä¹ç›¸å®¹æ‰€æœ‰ç¶²ç«™ï¼
// @description:en     NiceFont: Optimize web font display for clear, comfortable browsing! "Adjusts fonts directly, not page scalingâ€”no compromises!" Modify font size & style, save settings, apply to all pages. Supports one-time, scheduled, or dynamic adjustments, for subdomains or globally. Works on nearly all sites!
// @description:ko     NiceFont: ì›¹ í°íŠ¸ í‘œì‹œë¥¼ ìµœì í™”í•˜ì—¬ ì„ ëª…í•˜ê³  í¸ì•ˆí•œ ë¸Œë¼ìš°ì§•! "í˜ì´ì§€ë¥¼ ìŠ¤ì¼€ì¼ë§í•˜ì§€ ì•Šê³  í°íŠ¸ë¥¼ ì¡°ì •â€”íƒ€í˜‘ ì—†ìŒ!" í°íŠ¸ í¬ê¸°ì™€ ìŠ¤íƒ€ì¼ì„ ìˆ˜ì •, ì„¤ì • ì €ì¥, ëª¨ë“  í˜ì´ì§€ì— ì ìš©. ìµœì´ˆ, ì •ê¸°, ë™ì  ì¡°ì • ì§€ì›, ì„œë¸Œë„ë©”ì¸ ë˜ëŠ” ì „ì—­ ì„¤ì •. ê±°ì˜ ëª¨ë“  ì‚¬ì´íŠ¸ í˜¸í™˜!
// @description:ja     NiceFontï¼šã‚¦ã‚§ãƒ–ãƒ•ã‚©ãƒ³ãƒˆã‚’æœ€é©åŒ–ã—ã€ã‚¯ãƒªã‚¢ã§å¿«é©ãªé–²è¦§ã‚’ï¼ã€Œãƒšãƒ¼ã‚¸ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ä¸è¦ã€ãƒ•ã‚©ãƒ³ãƒˆã‚’ç›´æ¥èª¿æ•´â€”å¦¥å”ãªã—ï¼ã€ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã¨ã‚¹ã‚¿ã‚¤ãƒ«ã‚’å¤‰æ›´ã€è¨­å®šã‚’ä¿å­˜ã€å…¨ãƒšãƒ¼ã‚¸ã«é©ç”¨ã€‚åˆå›ã€å®šæœŸã€å‹•çš„èª¿æ•´ã‚’ã‚µãƒãƒ¼ãƒˆã€ã‚µãƒ–ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚„ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®šã«å¯¾å¿œã€‚ã»ã¼å…¨ã‚µã‚¤ãƒˆå¯¾å¿œï¼
// @description:ru     NiceFont: ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµÑ‚ Ğ²ĞµĞ±-ÑˆÑ€Ğ¸Ñ„Ñ‚Ñ‹ Ğ´Ğ»Ñ Ñ‡ĞµÑ‚ĞºĞ¾Ğ³Ğ¾ Ğ¸ ÑƒĞ´Ğ¾Ğ±Ğ½Ğ¾Ğ³Ğ¾ Ñ‡Ñ‚ĞµĞ½Ğ¸Ñ! "Ğ ĞµĞ³ÑƒĞ»Ğ¸Ñ€ÑƒĞµÑ‚ ÑˆÑ€Ğ¸Ñ„Ñ‚Ñ‹, Ğ° Ğ½Ğµ Ğ¼Ğ°ÑÑˆÑ‚Ğ°Ğ±Ğ¸Ñ€ÑƒĞµÑ‚ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ñƒ â€” Ğ½Ğ¸ĞºĞ°ĞºĞ¸Ñ… ĞºĞ¾Ğ¼Ğ¿Ñ€Ğ¾Ğ¼Ğ¸ÑÑĞ¾Ğ²!" Ğ˜Ğ·Ğ¼ĞµĞ½ÑĞµÑ‚ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ¸ ÑÑ‚Ğ¸Ğ»ÑŒ ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ°, ÑĞ¾Ñ…Ñ€Ğ°Ğ½ÑĞµÑ‚ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸, Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ÑĞµÑ‚ ĞºĞ¾ Ğ²ÑĞµĞ¼ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ğ°Ğ¼. ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµÑ‚ Ñ€Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğµ, Ğ¿Ğ»Ğ°Ğ½Ğ¾Ğ²Ñ‹Ğµ Ğ¸Ğ»Ğ¸ Ğ´Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸, Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ´Ğ´Ğ¾Ğ¼ĞµĞ½Ğ¾Ğ² Ğ¸Ğ»Ğ¸ Ğ³Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ğ¾. Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ğ¿Ğ¾Ñ‡Ñ‚Ğ¸ Ğ½Ğ° Ğ²ÑĞµÑ… ÑĞ°Ğ¹Ñ‚Ğ°Ñ…!
// @description:fr     NiceFont : Optimisez l'affichage des polices web pour une navigation claire et confortable ! Â« Ajuste les polices directement, pas de zoom de page â€” sans compromis ! Â» Modifie taille et style, enregistre les paramÃ¨tres, applique Ã  toutes les pages. Supporte ajustements uniques, programmÃ©s ou dynamiques, pour sous-domaines ou global. Compatible avec presque tous les sites !
// @description:de     NiceFont: Optimiert Webschrift fÃ¼r klares, angenehmes Surfen! "Passt Schriften direkt an, ohne Seiten-Skalierung â€” keine Kompromisse!" Ã„ndert SchriftgrÃ¶ÃŸe und -stil, speichert Einstellungen, wendet sie auf alle Seiten an. UnterstÃ¼tzt einmalige, geplante oder dynamische Anpassungen, fÃ¼r Subdomains oder global. Kompatibel mit fast allen Websites!
// @description:es     NiceFont: Optimiza fuentes web para una navegaciÃ³n clara y cÃ³moda. "Ajusta fuentes directamente, sin escalar pÃ¡gina â€” Â¡sin concesiones!" Modifica tamaÃ±o y estilo, guarda configuraciones, aplica a todas las pÃ¡ginas. Admite ajustes Ãºnicos, programados o dinÃ¡micos, para subdominios o global. Compatible con casi todos los sitios.
// @description:pt     NiceFont: Otimiza fontes web para navegaÃ§Ã£o clara e confortÃ¡vel! "Ajusta fontes diretamente, sem escalonar pÃ¡gina â€” sem concessÃµes!" Modifica tamanho e estilo, salva configuraÃ§Ãµes, aplica a todas as pÃ¡ginas. Suporta ajustes Ãºnicos, agendados ou dinÃ¢micos, para subdomÃ­nios ou global. CompatÃ­vel com quase todos os sites!
// @homepageURL   https://github.com/10D24D/NiceFont/
// @namespace    https://github.com/10D24D/NiceFont/
// @icon         https://raw.githubusercontent.com/10D24D/NiceFont/main/static/logo.png
// @downloadURL  https://update.greasyfork.org/scripts/533232/NiceFont.user.js
// @updateURL    https://update.greasyfork.org/scripts/533232/NiceFont.meta.js
// @match        *://*/*
// @license      Apache License 2.0
// @grant        GM_registerMenuCommand
// @grant        GM_unregisterMenuCommand
// @grant        GM_getValue
// @grant        GM_setValue
// @grant        GM_addStyle
// @grant        GM_info
// @run-at       document-start
// @compatible   edge versionâ‰¥90 (Compatible Tampermonkey, Violentmonkey)
// @compatible   Chrome versionâ‰¥90 (Compatible Tampermonkey, Violentmonkey)
// @compatible   Firefox versionâ‰¥84 (Compatible Greasemonkey, Tampermonkey, Violentmonkey)
// @compatible   Opera versionâ‰¥78 (Compatible Tampermonkey, Violentmonkey)
// @compatible   Safari versionâ‰¥15.4 (Compatible Tampermonkey, Userscripts)
// @create       2025-4-18
// @copyright    2025, DD1024z
// ==/UserScript==

(function () {
    'use strict';

    // è°ƒè¯•å¼€å…³ï¼Œç”Ÿäº§ç¯å¢ƒä¸­ç¦ç”¨æ—¥å¿—
    const enableLogging = false;

    // å…³é—­è·Ÿè¸ªå¸¸é‡
    const CLOSE_TRACKING_WINDOW = 1800 * 1000; // 30 åˆ†é’Ÿï¼ˆæ¯«ç§’ï¼‰
    const CLOSE_COUNT_THRESHOLD = 2; // è¿ç»­å…³é—­ä¸¤æ¬¡

    /**
     * è‡ªå®šä¹‰æ—¥å¿—å‡½æ•°ï¼Œä»…åœ¨è°ƒè¯•æ¨¡å¼ä¸‹è¾“å‡º
     * @param {...any} args - æ—¥å¿—å‚æ•°
     */
    function log(...args) {
        if (enableLogging) {
            console.log('[NiceFont]', ...args);
        }
    }

    // è·³è¿‡ iframe æ‰§è¡Œ
    if (window.top !== window.self) {
        log('è·³è¿‡ iframe æ‰§è¡Œ');
        return;
    }

    // --- å·¥å…·å‡½æ•°æ¨¡å— ---
    const Utils = {
        /**
         * èŠ‚æµå‡½æ•°ï¼Œé™åˆ¶å‡½æ•°è°ƒç”¨é¢‘ç‡
         * @param {Function} fn - è¦èŠ‚æµçš„å‡½æ•°
         * @param {number} wait - èŠ‚æµé—´éš”ï¼ˆæ¯«ç§’ï¼‰
         * @returns {Function} èŠ‚æµåçš„å‡½æ•°
         */
        throttle(fn, wait) {
            let lastCall = 0;
            return function (...args) {
                const now = Date.now();
                if (now - lastCall >= wait) {
                    lastCall = now;
                    fn(...args);
                }
            };
        },

        /**
         * å°†å­—ä½“å¤§å°å•ä½è½¬æ¢ä¸ºåƒç´ 
         * @param {HTMLElement} el - å…ƒç´ 
         * @param {string} fontSize - å­—ä½“å¤§å°ï¼ˆå¸¦å•ä½ï¼‰
         * @returns {number} åƒç´ å€¼
         */
        convertToPx(el, fontSize) {
            if (!fontSize) return 16;
            if (fontSize.includes('rem')) {
                const rootFontSize = parseFloat(window.getComputedStyle(document.documentElement).fontSize);
                return parseFloat(fontSize) * rootFontSize;
            }
            if (fontSize.includes('em')) {
                const parentFontSize = parseFloat(window.getComputedStyle(el.parentElement).fontSize);
                return parseFloat(fontSize) * parentFontSize;
            }
            if (fontSize.includes('%')) {
                const parentFontSize = parseFloat(window.getComputedStyle(el.parentElement).fontSize);
                return (parseFloat(fontSize) / 100) * parentFontSize;
            }
            if (fontSize.includes('pt')) {
                return parseFloat(fontSize) * 1.3333;
            }
            if (fontSize.includes('vw')) {
                return parseFloat(fontSize) * window.innerWidth / 100;
            }
            if (fontSize.includes('vh')) {
                return parseFloat(fontSize) * window.innerHeight / 100;
            }
            return parseFloat(fontSize);
        },

        /**
         * æ£€æŸ¥å…ƒç´ æ˜¯å¦åŒ…å«å¯è§æ–‡æœ¬
         * @param {HTMLElement} el - å…ƒç´ 
         * @returns {boolean} æ˜¯å¦åŒ…å«å¯è§æ–‡æœ¬
         */
        hasVisibleText(el) {
            return Array.from(el.childNodes).some(
                node => node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== ''
            );
        },

        /**
         * è·å–é¡¶çº§åŸŸå
         * @returns {string} é¡¶çº§åŸŸåï¼ˆå¦‚ .example.comï¼‰
         */
        getTopLevelDomain() {
            const hostname = window.location.hostname;
            const parts = hostname.split('.');
            return parts.length >= 2 ? `.${parts.slice(-2).join('.')}` : hostname;
        }
    };

    // --- çŠ¶æ€ç®¡ç† ---
    const State = {
        fontIncrement: 1,
        currentFontFamily: 'none',
        currentAdjustment: 0,
        watchDOMChanges: false,
        intervalSeconds: 0,
        firstAdjustment: false,
        firstAdjustmentTime: 3,
        currentLanguage: 'en',
        panelType: 'floating',
        isConfigModified: false,
        targetScope: 1,
        pendingScopeChange: null,
        observer: null,
        timer: null,

        /**
         * è·å–çŠ¶æ€å€¼
         * @param {string} key - çŠ¶æ€é”®
         * @returns {any} çŠ¶æ€å€¼
         */
        get(key) {
            return this[key];
        },

        /**
         * è®¾ç½®çŠ¶æ€å€¼
         * @param {string} key - çŠ¶æ€é”®
         * @param {any} value - çŠ¶æ€å€¼
         */
        set(key, value) {
            this[key] = value;
        }
    };

    // --- é…ç½®èŒƒå›´ç®¡ç† ---
    const ConfigScopeManager = {
        BASE_STORAGE_KEY: 'NiceFont_config',
        GLOBAL_DEFAULT_KEY: 'NiceFont_global_default_config',
        PANEL_TYPE_KEY: 'NiceFont_panelType',
        scopeMap: { 1: 'subdomain', 2: 'topLevelDomain', 3: 'allWebsites' },

        /**
         * åˆå§‹åŒ–åŠ¨æ€é”®
         */
        initKeys() {
            this.subdomainKey = `${this.BASE_STORAGE_KEY}_${window.location.hostname}`;
            this.topLevelKey = `${this.BASE_STORAGE_KEY}_${Utils.getTopLevelDomain()}`;
        },

        /**
         * è·å–å½“å‰é…ç½®é”®
         * @returns {string} é…ç½®é”®
         */
        getConfigKey() {
            this.initKeys();
            const scope = State.get('targetScope');
            if (scope === 1) return this.subdomainKey;
            if (scope === 2) return this.topLevelKey;
            return this.GLOBAL_DEFAULT_KEY;
        },

        /**
         * è·å–å½“å‰ç”Ÿæ•ˆçš„é…ç½®èŒƒå›´
         * @returns {number} èŒƒå›´ï¼ˆ1: å­åŸŸå, 2: é¡¶çº§åŸŸå, 3: æ‰€æœ‰ç½‘ç«™ï¼‰
         */
        getEffectiveScope() {
            this.initKeys();
            const subdomainConfig = GM_getValue(this.subdomainKey, {});
            const topLevelConfig = GM_getValue(this.topLevelKey, {});
            const globalConfig = GM_getValue(this.GLOBAL_DEFAULT_KEY, {});
            if (Object.keys(subdomainConfig).length > 0) return 1;
            if (Object.keys(topLevelConfig).length > 0) return 2;
            if (Object.keys(globalConfig).length > 0) return 3;
            return 1; // é»˜è®¤è¿”å›å­åŸŸå
        },

        /**
         * æ£€æŸ¥å½“å‰ç½‘ç«™æ˜¯å¦å·²æœ‰é…ç½®
         * @returns {boolean} æ˜¯å¦å­˜åœ¨é…ç½®
         */
        hasConfig() {
            this.initKeys();
            const configKey = this.getConfigKey();
            const config = GM_getValue(configKey, null);
            const hasConfig = !!config && Object.keys(config).length > 0;
            log(`æ£€æŸ¥é…ç½®: key=${configKey}, hasConfig=${hasConfig}, config=${JSON.stringify(config)}`);
            return hasConfig;
        },

        /**
         * è·å–èŒƒå›´æ˜¾ç¤ºæ–‡æœ¬
         * @param {number} scope - èŒƒå›´
         * @param {Object} t - ç¿»è¯‘å¯¹è±¡
         * @returns {string} æ˜¾ç¤ºæ–‡æœ¬
         */
        getScopeText(scope, t) {
            return scope === 1 ? t.subdomain : scope === 2 ? t.topLevelDomain : t.allWebsites;
        },

        /**
         * è·å–å½“å‰é…ç½®æ¥æºæ–‡æœ¬
         * @param {Object} t - ç¿»è¯‘å¯¹è±¡
         * @returns {string} é…ç½®æ¥æºæ–‡æœ¬
         */
        getCurrentConfigText(t) {
            this.initKeys();
            const subdomainConfig = GM_getValue(this.subdomainKey, {});
            const topLevelConfig = GM_getValue(this.topLevelKey, {});
            const globalConfig = GM_getValue(this.GLOBAL_DEFAULT_KEY, {});
            if (Object.keys(subdomainConfig).length > 0) return window.location.hostname;
            if (Object.keys(topLevelConfig).length > 0) return `*.${Utils.getTopLevelDomain().replace(/^\./, '')}`;
            if (Object.keys(globalConfig).length > 0) return t.allWebsites;
            return t.notConfigured;
        },

        /**
         * è·å–é…ç½®èŒƒå›´æ˜¾ç¤ºæ–‡æœ¬ï¼ˆåŒ…å«ç›®æ ‡èŒƒå›´ï¼‰
         * @param {Object} t - ç¿»è¯‘å¯¹è±¡
         * @returns {string} æ˜¾ç¤ºæ–‡æœ¬
         */
        getConfigScopeDisplayText(t) {
            const effectiveScope = this.getEffectiveScope();
            const currentScopeText = this.getScopeText(effectiveScope, t);
            const pendingScope = State.get('pendingScopeChange');
            if (pendingScope && pendingScope !== effectiveScope) {
                const targetScopeText = this.getScopeText(pendingScope, t);
                return `${currentScopeText} -> ${targetScopeText}`;
            }
            return currentScopeText;
        },

        /**
         * åˆ é™¤æŒ‡å®šèŒƒå›´çš„é…ç½®
         * @param {number} scope - èŒƒå›´
         * @returns {boolean} æ˜¯å¦åˆ é™¤æˆåŠŸ
         */
        deleteConfig(scope) {
            this.initKeys();
            const t = translations[State.get('currentLanguage')] || translations.en;
            let key, target;
            if (scope === 1) {
                key = this.subdomainKey;
                target = window.location.hostname;
            } else if (scope === 2) {
                key = this.topLevelKey;
                target = `*.${Utils.getTopLevelDomain().replace(/^\./, '')}`;
            } else {
                key = this.GLOBAL_DEFAULT_KEY;
                target = t.allWebsites;
            }
            GM_setValue(key, {});
            log(`åˆ é™¤é…ç½®: ${target}`);
            return true;
        }
    };

    // --- é…ç½®ç®¡ç† ---
    const ConfigManager = {
        /**
         * åŠ è½½é…ç½®
         */
        loadConfig() {
            ConfigScopeManager.initKeys();
            let config = GM_getValue(ConfigScopeManager.subdomainKey, {});
            let effectiveScope = 1;
            if (Object.keys(config).length === 0) {
                config = GM_getValue(ConfigScopeManager.topLevelKey, {});
                effectiveScope = 2;
                if (Object.keys(config).length === 0) {
                    config = GM_getValue(ConfigScopeManager.GLOBAL_DEFAULT_KEY, {});
                    effectiveScope = Object.keys(config).length > 0 ? 3 : 1; // ç©ºå…¨å±€é…ç½®æ—¶é»˜è®¤å­åŸŸå
                }
            }
            State.set('fontIncrement', config.increment || 1);
            State.set('currentFontFamily', config.fontFamily || 'none');
            State.set('currentAdjustment', config.resize || 0);
            State.set('watchDOMChanges', config.watcher || false);
            State.set('intervalSeconds', config.timer || 0);
            State.set('firstAdjustment', config.first || false);
            State.set('firstAdjustmentTime', config.firstTime || 3);
            State.set('targetScope', effectiveScope);
            log('åŠ è½½é…ç½®:', config, 'ç”Ÿæ•ˆèŒƒå›´:', effectiveScope);
        },

        /**
         * ä¿å­˜é…ç½®
         */
        saveConfig() {
            const t = translations[State.get('currentLanguage')] || translations.en;
            // ä½¿ç”¨ pendingScopeChangeï¼ˆè‹¥å­˜åœ¨ï¼‰ï¼Œå¦åˆ™ä½¿ç”¨ targetScope
            let scope = State.get('pendingScopeChange') !== null ? State.get('pendingScopeChange') : State.get('targetScope');
            // å¦‚æœé…ç½®å·²ä¿®æ”¹ä¸”æ—  pendingScopeChangeï¼Œä¼˜å…ˆä½¿ç”¨ UI æ˜¾ç¤ºçš„ scope
            if (State.get('isConfigModified') && State.get('pendingScopeChange') === null) {
                scope = ConfigScopeManager.getEffectiveScope();
                if (scope === 3 && Object.keys(GM_getValue(ConfigScopeManager.GLOBAL_DEFAULT_KEY, {})).length === 0) {
                    scope = 1; // æ— å…¨å±€é…ç½®æ—¶ï¼Œé»˜è®¤å­åŸŸå
                }
            }
            const scopeText = ConfigScopeManager.getScopeText(scope, t);
            const target = scope === 1 ? window.location.hostname :
                scope === 2 ? `*.${Utils.getTopLevelDomain().replace(/^\./, '')}` : t.allWebsites;
            const confirmMessage = scope === 3 ?
                t.saveConfigConfirm.replace('{scope}', scopeText).replace(' [{target}]', '') :
                t.saveConfigConfirm.replace('{scope}', scopeText).replace('{target}', target);

            if (confirm(confirmMessage)) {
                const config = {
                    increment: State.get('fontIncrement'),
                    resize: State.get('currentAdjustment'),
                    watcher: State.get('watchDOMChanges'),
                    timer: State.get('intervalSeconds'),
                    fontFamily: State.get('currentFontFamily'),
                    first: State.get('firstAdjustment'),
                    firstTime: State.get('firstAdjustmentTime')
                };
                ConfigScopeManager.initKeys();
                const key = scope === 1 ? ConfigScopeManager.subdomainKey :
                    scope === 2 ? ConfigScopeManager.topLevelKey : ConfigScopeManager.GLOBAL_DEFAULT_KEY;
                GM_setValue(key, config);
                State.set('isConfigModified', false);
                State.set('targetScope', scope);
                State.set('pendingScopeChange', null);
                ConfigManager.loadConfig(); // åˆ·æ–°é…ç½®
                UIManager.updateUI();
                log(`ä¿å­˜é…ç½®åˆ°: ${target} (scope=${scope})`);
            }
        },

        /**
         * æ›´æ”¹é…ç½®èŒƒå›´
         */
        changeConfigScope() {
            const t = translations[State.get('currentLanguage')] || translations.en;
            const effectiveScope = ConfigScopeManager.getEffectiveScope();
            const currentScopeText = ConfigScopeManager.getScopeText(effectiveScope, t);
            const input = prompt(
                t.configScopePrompt
                    .replace('{scope}', currentScopeText)
                    .replace('{hostname}', window.location.hostname)
                    .replace('{tld}', Utils.getTopLevelDomain().replace(/^\./, '')),
                State.get('targetScope')
            );
            const newScope = parseInt(input, 10);
            if (![1, 2, 3].includes(newScope)) {
                if (input !== null) alert(t.invalidInput);
                return;
            }
            if (newScope === effectiveScope) {
                log(`æ–°èŒƒå›´ä¸å½“å‰èŒƒå›´ç›¸åŒ: ${ConfigScopeManager.scopeMap[newScope]}`);
                return;
            }
            ConfigScopeManager.initKeys();
            const hasConfig = effectiveScope === 1 ? Object.keys(GM_getValue(ConfigScopeManager.subdomainKey, {})).length > 0 :
                effectiveScope === 2 ? Object.keys(GM_getValue(ConfigScopeManager.topLevelKey, {})).length > 0 :
                    Object.keys(GM_getValue(ConfigScopeManager.GLOBAL_DEFAULT_KEY, {})).length > 0;

            if (newScope > effectiveScope && hasConfig) {
                const confirmMessage = effectiveScope === 3 ?
                    `${t.currentConfigScope}: ${ConfigScopeManager.getCurrentConfigText(t)}\n${t.deleteBeforeScopeChangeConfirm.replace('{scope}', ConfigScopeManager.getScopeText(effectiveScope, t)).replace(' [{target}]', '')}` :
                    `${t.currentConfigScope}: ${ConfigScopeManager.getCurrentConfigText(t)}\n${t.deleteBeforeScopeChangeConfirm.replace('{scope}', ConfigScopeManager.getScopeText(effectiveScope, t)).replace('{target}', ConfigScopeManager.getCurrentConfigText(t))}`;
                if (confirm(confirmMessage)) {
                    ConfigScopeManager.deleteConfig(effectiveScope);
                    State.set('pendingScopeChange', newScope);
                    State.set('targetScope', newScope);
                    State.set('isConfigModified', true);
                    UIManager.updateUI();
                    log(`æ ‡è®°èŒƒå›´æ›´æ”¹ä¸º: ${ConfigScopeManager.scopeMap[newScope]}`);
                }
            } else {
                State.set('pendingScopeChange', newScope);
                State.set('targetScope', newScope);
                State.set('isConfigModified', true);
                UIManager.updateUI();
                log(`æ ‡è®°èŒƒå›´æ›´æ”¹ä¸º: ${ConfigScopeManager.scopeMap[newScope]}`);
            }
        },

        /**
         * åˆ é™¤å½“å‰é…ç½®
         */
        deleteCurrentConfig() {
            const effectiveScope = ConfigScopeManager.getEffectiveScope();
            const t = translations[State.get('currentLanguage')] || translations.en;
            const scopeText = ConfigScopeManager.getScopeText(effectiveScope, t);
            const target = ConfigScopeManager.getCurrentConfigText(t);

            if (target === t.notConfigured) {
                log('æ— é…ç½®å¯åˆ é™¤');
                return false;
            }

            const confirmMessage = effectiveScope === 3 ?
                `${t.currentConfigScope}: ${target}\n${t.deleteConfigConfirm.replace('{scope}', scopeText).replace(' [{target}]', '')}` :
                `${t.currentConfigScope}: ${target}\n${t.deleteConfigConfirm.replace('{scope}', scopeText).replace('{target}', target)}`;

            if (confirm(confirmMessage)) {
                ConfigScopeManager.deleteConfig(effectiveScope);
                State.set('targetScope', 1); // å¼ºåˆ¶è®¾ä¸ºå­åŸŸå
                State.set('pendingScopeChange', null); // æ¸…ç©ºå¾…å®šèŒƒå›´
                ConfigManager.loadConfig();
                UIManager.updateUI();
                log('é…ç½®å·²åˆ é™¤ï¼ŒtargetScope é‡ç½®ä¸º 1');
                return true;
            }
            return false;
        }
    };

    // --- å­—ä½“ç®¡ç† ---
    const FontManager = {
        supportFonts: [
            'custom', 'auto', 'none', 'Arial', 'cursive', 'fangsong', 'fantasy', 'monospace',
            'sans-serif', 'serif', 'system-ui', 'ui-monospace', 'ui-rounded', 'ui-sans-serif',
            'ui-serif', '-webkit-body', 'inherit', 'initial', 'unset', 'Verdana', 'Helvetica',
            'Tahoma', 'Times New Roman', 'Georgia', 'Courier New', 'Comic Sans MS'
        ],
        styleCache: new WeakMap(),

        /**
         * è·å–ç¼“å­˜çš„è®¡ç®—æ ·å¼
         * @param {HTMLElement} el - å…ƒç´ 
         * @returns {CSSStyleDeclaration} è®¡ç®—æ ·å¼
         */
        getCachedStyle(el) {
            if (!this.styleCache.has(el)) {
                this.styleCache.set(el, window.getComputedStyle(el));
            }
            return this.styleCache.get(el);
        },

        /**
         * é€’å½’éå† DOM å…ƒç´ 
         * @param {HTMLElement} el - æ ¹å…ƒç´ 
         * @param {Function} callback - å›è°ƒå‡½æ•°
         */
        traverseDOM(el, callback) {
            if (el.nodeType !== Node.ELEMENT_NODE || el.id === 'NiceFont_panel' || el.hasAttribute('data-nicefont-panel')) {
                return;
            }
            callback(el);
            if (el.tagName === 'IFRAME') {
                try {
                    const iframeDoc = el.contentDocument || el.contentWindow.document;
                    if (iframeDoc && iframeDoc.body) {
                        const font = State.get('currentFontFamily');
                        if (font !== 'none') {
                            iframeDoc.documentElement.style.fontFamily = font;
                        } else {
                            iframeDoc.documentElement.style.removeProperty('font-family');
                        }
                        this.traverseDOM(iframeDoc.body, callback);
                    }
                } catch (e) {
                    console.error('[NiceFont] è®¿é—® iframe å¤±è´¥:', e);
                }
            }
            if (el.shadowRoot) {
                try {
                    el.shadowRoot.querySelectorAll('*').forEach(child => this.traverseDOM(child, callback));
                } catch (e) {
                    console.error('[NiceFont] å¤„ç† Shadow DOM å¤±è´¥:', e);
                }
            }
            Array.from(el.children).forEach(child => requestAnimationFrame(() => this.traverseDOM(child, callback)));
        },

        /**
         * åº”ç”¨å­—ä½“è°ƒæ•´
         * @param {HTMLElement} el - æ ¹å…ƒç´ 
         * @param {number} increment - å­—ä½“å¤§å°å¢é‡ï¼ˆpxï¼‰
         */
        applyFontRecursively(el, increment) {
            const font = State.get('currentFontFamily');
            this.traverseDOM(el, (node) => {
                const style = this.getCachedStyle(node);
                const isVisible = style.display !== 'none' && style.visibility !== 'hidden';
                if (Utils.hasVisibleText(node) && isVisible) {
                    let currentFontSize = node.style.fontSize || style.fontSize;
                    if (!node.hasAttribute('data-default-fontsize')) {
                        node.setAttribute('data-default-fontsize', currentFontSize);
                    }
                    const baseFontSize = parseFloat(Utils.convertToPx(node, node.getAttribute('data-default-fontsize')));
                    if (!isNaN(baseFontSize)) {
                        node.style.fontSize = `${baseFontSize + increment}px`;
                    }
                    if (font !== 'none') {
                        node.style.fontFamily = font; // ä¿®å¤ï¼šfontFfamily -> fontFamily
                    } else {
                        node.style.removeProperty('font-family');
                    }
                }
            });
        },

        /**
         * é‡ç½®å­—ä½“
         * @param {HTMLElement} el - æ ¹å…ƒç´ 
         */
        resetFont(el) {
            this.traverseDOM(el, (node) => {
                const defaultSize = node.getAttribute('data-default-fontsize');
                if (defaultSize) {
                    node.style.fontSize = defaultSize;
                    node.removeAttribute('data-default-fontsize');
                } else {
                    node.style.removeProperty('font-size');
                }
                node.style.removeProperty('font-family');
            });
            // é‡ç½®å…³é—­è·Ÿè¸ªçŠ¶æ€
            GM_setValue('NiceFont_closeCount', 0);
            GM_setValue('NiceFont_lastCloseTime', 0);
            GM_setValue('NiceFont_autoOpenDisabled', false);
            log('é‡ç½®å…³é—­è·Ÿè¸ªçŠ¶æ€');
        },

        /**
         * ä¿®æ”¹å­—ä½“å¤§å°
         * @param {number} increment - å¢é‡ï¼ˆpxï¼‰
         */
        changeFontSize(increment) {
            State.set('currentAdjustment', State.get('currentAdjustment') + increment);
            this.applyFontRecursively(document.body, State.get('currentAdjustment'));
            State.set('isConfigModified', true);
            UIManager.updateUI();
            log(`å­—ä½“å¤§å°è°ƒæ•´: ${increment}px, å½“å‰: ${State.get('currentAdjustment')}px`);
        }
    };

    // --- ç•Œé¢ç®¡ç† ---
    const UIManager = {
        menuHandles: [],
        panelCache: null,
        overlayCache: null,
        lastToggleTime: 0, // ç”¨äºé˜²æŠ–

        /**
         * å®šä¹‰å‘½ä»¤é…ç½®
         * @returns {Array} å‘½ä»¤é…ç½®æ•°ç»„
         */
        getCommandsConfig() {
            const t = translations[State.get('currentLanguage')] || translations.en;
            return [
                {
                    id: 'setFontFamily',
                    getText: () => `ğŸ”  ${t.setFontFamily}: ${State.get('currentFontFamily')}`,
                    action: () => {
                        const t = translations[State.get('currentLanguage')] || translations.en;
                        if (State.get('panelType') === 'tampermonkey') {
                            // æ²¹çŒ´èœå•æ¨¡å¼ä¸‹ç›´æ¥å¼¹å‡ºæç¤ºæ¡†
                            const input = prompt(`${t.setFontFamilyPrompt}\n\n${t.supportFontFamily}\n${FontManager.supportFonts.join(', ')}`, State.get('currentFontFamily') === 'none' ? '' : State.get('currentFontFamily'));
                            if (input && input.trim()) {
                                const newFont = input.trim();
                                if (!FontManager.supportFonts.includes(newFont)) {
                                    FontManager.supportFonts.splice(FontManager.supportFonts.length - 1, 0, newFont);
                                }
                                State.set('currentFontFamily', newFont);
                                FontManager.applyFontRecursively(document.body, State.get('currentAdjustment'));
                                State.set('isConfigModified', true);
                                UIManager.updateUI();
                                log(`å­—ä½“ç±»å‹è®¾ç½®ä¸º: ${newFont}`);
                            } else {
                                log('å–æ¶ˆå­—ä½“è¾“å…¥');
                            }
                        } else {
                            // æµ®åŠ¨é¢æ¿æ¨¡å¼ä¿æŒåŸæœ‰é€»è¾‘
                            let select = document.getElementById('NiceFont_font-family');
                            if (select) {
                                select.remove();
                                document.removeEventListener('click', this.closeDropdown);
                                return;
                            }
                            select = document.createElement('select');
                            select.id = 'NiceFont_font-family';
                            select.className = 'font-family-select';
                            select.innerHTML = FontManager.supportFonts.map(font =>
                                `<option value="${font}" ${font === State.get('currentFontFamily') ? 'selected' : ''}>${font === 'custom' ? (State.get('currentLanguage') === 'zh' ? 'æ‰‹åŠ¨è¾“å…¥' : 'Custom Input') : font}</option>`
                            ).join('');
                            const btn = document.getElementById('NiceFont_setFontFamily');
                            if (btn) btn.appendChild(select);
                            select.focus();
                            select.addEventListener('click', e => e.stopPropagation());
                            select.addEventListener('change', (e) => {
                                const selectedFont = e.target.value;
                                if (selectedFont === 'custom') {
                                    const input = prompt(`${t.setFontFamilyPrompt}\n\n${t.supportFontFamily}\n${FontManager.supportFonts.slice(0, -1).join(', ')}`, '');
                                    if (input && input.trim()) {
                                        const newFont = input.trim();
                                        if (!FontManager.supportFonts.includes(newFont)) {
                                            FontManager.supportFonts.splice(FontManager.supportFonts.length - 1, 0, newFont);
                                            const option = document.createElement('option');
                                            option.value = newFont;
                                            option.textContent = newFont;
                                            select.insertBefore(option, select.lastChild);
                                        }
                                        State.set('currentFontFamily', newFont);
                                        select.value = newFont;
                                    } else {
                                        select.value = State.get('currentFontFamily');
                                        select.remove();
                                        document.removeEventListener('click', this.closeDropdown);
                                        log('å–æ¶ˆè‡ªå®šä¹‰å­—ä½“è¾“å…¥');
                                        return;
                                    }
                                } else {
                                    State.set('currentFontFamily', selectedFont);
                                }
                                FontManager.applyFontRecursively(document.body, State.get('currentAdjustment'));
                                State.set('isConfigModified', true);
                                UIManager.updateUI();
                                select.remove();
                                document.removeEventListener('click', this.closeDropdown);
                                log(`å­—ä½“ç±»å‹è®¾ç½®ä¸º: ${State.get('currentFontFamily')}`);
                            });
                            this.closeDropdown = (event) => {
                                if (!select.contains(event.target) && !btn.contains(event.target)) {
                                    select.remove();
                                    document.removeEventListener('click', this.closeDropdown);
                                    log('ä¸‹æ‹‰èœå•å…³é—­');
                                }
                            };
                            document.addEventListener('click', this.closeDropdown);
                        }
                    }
                },
                {
                    id: 'status',
                    getText: () => `ğŸ“ ${t.fontSizeAdjustment}: ${State.get('currentAdjustment') >= 0 ? '+' : ''}${State.get('currentAdjustment')}px`,
                    action: () => { }
                },
                {
                    id: 'increase',
                    getText: () => `ğŸ”¼ ${t.increase}`,
                    action: () => FontManager.changeFontSize(State.get('fontIncrement')),
                    autoClose: false
                },
                {
                    id: 'decrease',
                    getText: () => `ğŸ”½ ${t.decrease}`,
                    action: () => FontManager.changeFontSize(-State.get('fontIncrement')),
                    autoClose: false
                },
                {
                    id: 'reset',
                    getText: () => `ğŸ”„ï¸ ${t.reset}`,
                    action: () => {
                        FontManager.resetFont(document.body);
                        State.set('currentAdjustment', 0);
                        State.set('currentFontFamily', 'none');
                        State.set('watchDOMChanges', false);
                        State.set('intervalSeconds', 0);
                        State.set('firstAdjustment', false);
                        State.set('firstAdjustmentTime', 3);
                        if (State.get('observer')) {
                            State.get('observer').disconnect();
                            State.set('observer', null);
                        }
                        if (State.get('timer')) {
                            clearInterval(State.get('timer'));
                            State.set('timer', null);
                        }
                        State.set('isConfigModified', true);
                        UIManager.updateUI();
                        log('å­—ä½“è®¾ç½®é‡ç½®');
                    }
                },
                {
                    id: 'first-adjustment',
                    getText: () => `1ï¸âƒ£ ${State.get('firstAdjustment') ? t.firstAdjustmentEnabled : t.firstAdjustmentDisabled} ${State.get('firstAdjustment') ? `ã€${State.get('firstAdjustmentTime')}sã€‘` : ''}`,
                    action: () => {
                        const input = prompt(t.firstAdjustmentConfirm, State.get('firstAdjustmentTime').toString());
                        const secs = parseInt(input, 10);
                        if (!isNaN(secs)) {
                            State.set('firstAdjustment', !State.get('firstAdjustment'));
                            State.set('firstAdjustmentTime', secs);
                            if (secs === 0) State.set('firstAdjustment', false);
                            if (State.get('firstAdjustment')) {
                                setTimeout(() => {
                                    FontManager.applyFontRecursively(document.body, State.get('currentAdjustment'));
                                    log('åº”ç”¨é¦–æ¬¡å­—ä½“è°ƒæ•´');
                                }, State.get('firstAdjustmentTime') * 1000);
                            }
                            State.set('isConfigModified', true);
                            if (this.panelCache) {
                                this.updatePanelContent();
                            }
                            log(`é¦–æ¬¡è°ƒæ•´è®¾ç½®ä¸º: ${secs}s`);
                        }
                    }
                },
                {
                    id: 'timer-adjustment',
                    getText: () => `â±ï¸ ${State.get('intervalSeconds') > 0 ? t.timerAdjustmentEnabled : t.timerAdjustmentDisabled} ${State.get('intervalSeconds') > 0 ? `ã€${State.get('intervalSeconds')}sã€‘` : ''}`,
                    action: () => {
                        const input = prompt(t.timerPrompt, State.get('intervalSeconds').toString());
                        const secs = parseInt(input, 10);
                        if (!isNaN(secs)) {
                            State.set('intervalSeconds', secs);
                            if (secs > 0) {
                                State.set('watchDOMChanges', false);
                                if (State.get('observer')) State.get('observer').disconnect();
                                if (State.get('timer')) clearInterval(State.get('timer'));
                                State.set('timer', setInterval(() => {
                                    FontManager.applyFontRecursively(document.body, State.get('currentAdjustment'));
                                }, secs * 1000));
                                log(`å®šæ—¶è°ƒæ•´è®¾ç½®ä¸º: ${secs}s`);
                            } else {
                                if (State.get('timer')) clearInterval(State.get('timer'));
                                log('å®šæ—¶è°ƒæ•´ç¦ç”¨');
                            }
                            State.set('isConfigModified', true);
                            if (this.panelCache) {
                                this.updatePanelContent();
                            }
                            log(`å®šæ—¶è°ƒæ•´è®¾ç½®ä¸º: ${secs}s`);
                        }
                    }
                },
                {
                    id: 'dynamic-adjustment',
                    getText: () => `ğŸ” ${State.get('watchDOMChanges') ? t.dynamicAdjustmentEnabled : t.dynamicAdjustmentDisabled}`,
                    action: () => {
                        if (confirm(t.dynamicWatchConfirm)) {
                            State.set('watchDOMChanges', !State.get('watchDOMChanges'));
                            if (State.get('watchDOMChanges')) {
                                State.set('intervalSeconds', 0);
                                if (State.get('timer')) clearInterval(State.get('timer'));
                                const nodeCount = document.body.getElementsByTagName('*').length;
                                const throttleTime = nodeCount > 10000 ? 200 : 100;
                                State.set('observer', new MutationObserver(Utils.throttle(() => {
                                    FontManager.applyFontRecursively(document.body, State.get('currentAdjustment'));
                                }, throttleTime)));
                                State.get('observer').observe(document.body, { childList: true, subtree: true });
                                log('åŠ¨æ€è°ƒæ•´å¯ç”¨');
                            } else {
                                if (State.get('observer')) State.get('observer').disconnect();
                                log('åŠ¨æ€è°ƒæ•´ç¦ç”¨');
                            }
                            State.set('isConfigModified', true);
                            if (this.panelCache) {
                                this.updatePanelContent();
                            }
                        }
                    }
                },
                {
                    id: 'switch-language',
                    getText: () => `ğŸŒ ${t.usageLanguage}: ${State.get('currentLanguage')}`,
                    action: () => {
                        let input;
                        do {
                            input = prompt('zh: æ±‰è¯­ \t en: English \t ko: í•œêµ­ì–´ \t ja: æ—¥æœ¬èª \t ru: Ğ ÑƒÑÑĞºĞ¸Ğ¹ \t fr: FranÃ§ais \t de: Deutsch \t es: EspaÃ±ol \t pt: PortuguÃªs', State.get('currentLanguage'));
                            if (input && !Object.keys(translations).includes(input.trim())) {
                                alert('Invalid language code!');
                            }
                        } while (input && !Object.keys(translations).includes(input.trim()));
                        if (input && input.trim()) {
                            const newLanguage = input.trim();
                            State.set('currentLanguage', newLanguage);
                            GM_setValue('language', newLanguage);
                            log(`è¯­è¨€åˆ‡æ¢ä¸º: ${newLanguage}`);

                            // æ›´æ–°ç°æœ‰é¢æ¿å†…å®¹ï¼Œè€Œä¸æ˜¯é”€æ¯
                            if (UIManager.panelCache && document.body.contains(UIManager.panelCache)) {
                                UIManager.updatePanelContent();
                                // æ ¹æ®é…ç½®å†³å®šæ˜¯å¦ç«‹å³æ˜¾ç¤ºé¢æ¿
                                const autoShow = GM_getValue('NiceFont_autoShowAfterLanguageSwitch', true);
                                if (autoShow) {
                                    UIManager.panelCache.style.display = 'block';
                                    UIManager.overlayCache.style.display = 'block';
                                    log('è¯­è¨€åˆ‡æ¢åè‡ªåŠ¨æ˜¾ç¤ºé¢æ¿');
                                }
                            } else {
                                // å¦‚æœé¢æ¿ä¸å­˜åœ¨ï¼Œåˆ›å»ºå¹¶æ ¹æ®é…ç½®æ˜¾ç¤º
                                UIManager.createFloatingPanel();
                                if (UIManager.panelCache) {
                                    const autoShow = GM_getValue('NiceFont_autoShowAfterLanguageSwitch', true);
                                    UIManager.panelCache.style.display = autoShow ? 'block' : 'none';
                                    UIManager.overlayCache.style.display = autoShow ? 'block' : 'none';
                                    log(`é¢æ¿åˆ›å»ºåï¼Œæ˜¾ç¤ºçŠ¶æ€: ${autoShow ? 'block' : 'none'}`);
                                } else {
                                    console.error('[NiceFont] è¯­è¨€åˆ‡æ¢ååˆ›å»ºé¢æ¿å¤±è´¥');
                                }
                            }
                            UIManager.updateUI();
                        }
                    }
                },
                {
                    id: 'switch-panel',
                    getText: () => `ğŸ¨ ${t.switchPanel}: ${State.get('panelType') === 'tampermonkey' ? t.tampermonkeyPanel : t.floatingPanel}`,
                    action: () => {
                        const newPanelType = State.get('panelType') === 'tampermonkey' ? 'floating' : 'tampermonkey';
                        GM_setValue(ConfigScopeManager.PANEL_TYPE_KEY, newPanelType);
                        State.set('panelType', newPanelType);
                        if (this.panelCache) {
                            this.panelCache.remove();
                            this.overlayCache.remove();
                            this.panelCache = null;
                            this.overlayCache = null;
                            log('ç§»é™¤ç°æœ‰æµ®åŠ¨é¢æ¿');
                        }
                        if (newPanelType === 'floating') {
                            // ç›´æ¥åˆ›å»ºå¹¶æ˜¾ç¤ºæµ®åŠ¨é¢æ¿ï¼Œä¸æ£€æŸ¥é…ç½®æº
                            this.createFloatingPanel();
                            if (this.panelCache) {
                                this.panelCache.style.display = 'block';
                                this.overlayCache.style.display = 'block';
                                log('ç›´æ¥åˆ›å»ºå¹¶æ˜¾ç¤ºæµ®åŠ¨é¢æ¿ï¼ˆåˆ‡æ¢åˆ°ç½‘é¡µèœå•æ¨¡å¼ï¼‰');
                            }
                        }
                        UIManager.updateUI();
                        log(`åˆ‡æ¢åˆ°é¢æ¿ç±»å‹: ${newPanelType}`);
                    }
                },
                {
                    id: 'show-panel',
                    getText: () => `ğŸ“… ${t.showPanel}`,
                    action: () => this.togglePanel(),
                    tampermonkeyOnly: true
                },
                {
                    id: 'currentConfigScope',
                    getText: () => `ğŸ“ ${t.currentConfigScope}: ${ConfigScopeManager.getCurrentConfigText(t)}`,
                    action: ConfigManager.deleteCurrentConfig
                },
                {
                    id: 'config-scope',
                    getText: () => `â„¹ï¸ ${t.configScope}: ${ConfigScopeManager.getConfigScopeDisplayText(t)}`,
                    action: ConfigManager.changeConfigScope
                },
                {
                    id: 'save-config',
                    getText: () => `ğŸ’¾ ${State.get('isConfigModified') ? t.saveConfigPending : t.saveConfig}`,
                    action: ConfigManager.saveConfig
                }
            ];
        },

        /**
         * åˆ›å»ºæµ®åŠ¨é¢æ¿
         */
        createFloatingPanel() {
            if (this.panelCache && document.body.contains(this.panelCache)) {
                log('panelCache å·²å­˜åœ¨ä¸”åœ¨ DOM ä¸­ï¼Œè·³è¿‡åˆ›å»º');
                return;
            }
            // æ¸…ç†ç°æœ‰é¢æ¿
            if (this.panelCache) {
                this.panelCache.remove();
                this.overlayCache.remove();
                this.panelCache = null;
                this.overlayCache = null;
                log('æ¸…ç†ç°æœ‰ panelCache');
            }

            const t = translations[State.get('currentLanguage')] || translations.en;
            const scriptName = GM_info?.script?.name || 'NiceFont';

            // ç¡®ä¿ DOM å·²å°±ç»ª
            if (!document.body) {
                console.error('[NiceFont] document.body ä¸å¯ç”¨ï¼Œå»¶è¿Ÿåˆ›å»ºé¢æ¿');
                return;
            }

            // åˆå§‹åŒ–é¢æ¿
            this.panelCache = document.createElement('div');
            this.panelCache.id = 'NiceFont_panel';
            this.panelCache.setAttribute('data-nicefont-panel', 'true');
            this.panelCache.style.position = 'fixed';
            this.panelCache.style.width = '300px';
            this.panelCache.style.background = '#fff';
            this.panelCache.style.border = '1px solid #ccc';
            this.panelCache.style.borderRadius = '5px';
            this.panelCache.style.padding = '10px';
            this.panelCache.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
            this.panelCache.style.zIndex = '10001';
            this.panelCache.style.fontFamily = 'sans-serif';
            this.panelCache.style.fontSize = '15px';
            this.panelCache.style.userSelect = 'none';
            this.panelCache.style.display = 'none'; // é»˜è®¤éšè—

            // åˆå§‹åŒ–é®ç½©å±‚
            this.overlayCache = document.createElement('div');
            this.overlayCache.id = 'NiceFont_overlay';
            this.overlayCache.style.display = 'none';

            // åŠ è½½ä¿å­˜çš„é¢æ¿ä½ç½®
            const savedPosition = GM_getValue('NiceFont_panelPosition', { top: '50px', right: '20px' });
            this.panelCache.style.top = savedPosition.top;
            this.panelCache.style.right = savedPosition.right;
            this.panelCache.style.left = 'auto';

            // è®¾ç½®é¢æ¿å†…å®¹
            this.panelCache.innerHTML = `
            <div class="NiceFont_header" style="position: relative; z-index: 10002; display: flex; align-items: center; justify-content: space-between;">
                <div style="font-size: 16px; text-align: left; flex-grow: 1; cursor: grab; margin: 5px; font-weight: bold;">${scriptName}</div>
                <button class="NiceFont_close-btn" id="NiceFont_close-btn" style="border: none; border-radius: 3px; padding: 1px 6px; cursor: pointer; line-height: 16px; font-size: 12px; background: none; color: #000;">âœ–ï¸</button>
            </div>
            <div class="NiceFont_content"></div>
        `;

            // å¡«å……å†…å®¹åŒºåŸŸ
            this.updatePanelContent();

            // æ·»åŠ åˆ° DOM
            try {
                document.body.appendChild(this.overlayCache);
                document.body.appendChild(this.panelCache);
                log('æµ®åŠ¨é¢æ¿åˆ›å»ºå¹¶æ·»åŠ åˆ° DOM');
            } catch (e) {
                console.error('[NiceFont] æ·»åŠ é¢æ¿åˆ° DOM å¤±è´¥:', e);
                this.panelCache = null;
                this.overlayCache = null;
                return;
            }

            // è·å– header å…ƒç´ 
            const header = this.panelCache.querySelector('.NiceFont_header');
            if (!header) {
                console.error('[NiceFont] æœªæ‰¾åˆ° .NiceFont_headerï¼Œæ— æ³•ç»‘å®šæ‹–æ‹½äº‹ä»¶');
                this.panelCache.remove();
                this.overlayCache.remove();
                this.panelCache = null;
                this.overlayCache = null;
                return;
            }

            // æ·»åŠ æ‹–åŠ¨åŠŸèƒ½
            let isDragging = false;
            let initialX;
            let initialY;
            let rafId = null;

            header.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('NiceFont_close-btn')) {
                    log('ç‚¹å‡»å…³é—­æŒ‰é’®ï¼Œå¿½ç•¥æ‹–æ‹½');
                    return;
                }
                isDragging = true;
                initialX = e.clientX + parseFloat(this.panelCache.style.right || '0');
                initialY = e.clientY - parseFloat(this.panelCache.style.top || '0');
                header.style.cursor = 'grabbing';
                log('å¼€å§‹æ‹–æ‹½');
                e.preventDefault();
                e.stopPropagation();
            }, { capture: true, passive: false });

            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    e.preventDefault();
                    if (rafId) cancelAnimationFrame(rafId);
                    rafId = requestAnimationFrame(() => {
                        let newX = initialX - e.clientX;
                        let newY = e.clientY - initialY;
                        newX = Math.max(0, Math.min(newX, window.innerWidth - this.panelCache.offsetWidth));
                        newY = Math.max(0, Math.min(newY, window.innerHeight - this.panelCache.offsetHeight));
                        this.panelCache.style.right = `${newX}px`;
                        this.panelCache.style.top = `${newY}px`;
                        this.panelCache.style.left = 'auto';
                        log(`æ‹–æ‹½ä¸­: right=${newX}px, top=${newY}px`);
                    });
                }
            }, { capture: true, passive: false });

            document.addEventListener('mouseup', (e) => {
                if (isDragging) {
                    isDragging = false;
                    header.style.cursor = 'grab';
                    if (rafId) {
                        cancelAnimationFrame(rafId);
                        rafId = null;
                    }
                    GM_setValue('NiceFont_panelPosition', {
                        top: this.panelCache.style.top,
                        right: this.panelCache.style.right
                    });
                    log('æ‹–æ‹½ç»“æŸ, é¢æ¿ä½ç½®ä¿å­˜:', this.panelCache.style.top, this.panelCache.style.right);
                    e.stopPropagation();
                }
            }, { capture: true, passive: false });

            // æ·»åŠ é•¿æŒ‰åŠŸèƒ½
            let longPressTimer = null;
            const startLongPress = (action, interval = 100) => {
                action();
                longPressTimer = setInterval(action, interval);
            };
            const stopLongPress = () => {
                if (longPressTimer) {
                    clearInterval(longPressTimer);
                    longPressTimer = null;
                }
            };

            this.panelCache.addEventListener('mousedown', (e) => {
                const btn = e.target.closest('.action-btn');
                if (btn) {
                    const commandId = btn.id.replace('NiceFont_', '');
                    if (commandId === 'increase' || commandId === 'decrease') {
                        const command = this.getCommandsConfig().find(c => c.id === commandId);
                        if (command) {
                            startLongPress(command.action);
                        }
                    }
                }
            }, { capture: false });

            this.panelCache.addEventListener('mouseup', stopLongPress, { capture: false });
            this.panelCache.addEventListener('mouseleave', stopLongPress, { capture: false });

            // ç»‘å®šç‚¹å‡»äº‹ä»¶
            this.panelCache.addEventListener('click', (e) => {
                const btn = e.target.closest('.action-btn');
                if (btn) {
                    const command = this.getCommandsConfig().find(c => c.id === btn.id.replace('NiceFont_', ''));
                    if (command && command.id !== 'increase' && command.id !== 'decrease') {
                        log(`æ‰§è¡Œå‘½ä»¤: ${command.id}`);
                        command.action();
                    }
                }
                if (e.target.id === 'NiceFont_close-btn') {
                    this.panelCache.style.display = 'none';
                    this.overlayCache.style.display = 'none';
                    // æ£€æŸ¥æ˜¯å¦å› æ— é…ç½®è‡ªåŠ¨å¼¹å‡º
                    if (!ConfigScopeManager.hasConfig()) {
                        const now = Date.now();
                        const lastCloseTime = GM_getValue('NiceFont_lastCloseTime', 0);
                        let closeCount = GM_getValue('NiceFont_closeCount', 0);

                        if (now - lastCloseTime > CLOSE_TRACKING_WINDOW) {
                            closeCount = 0;
                            log('å…³é—­è®¡æ•°é‡ç½®ï¼ˆè¶…å‡ºæ—¶é—´çª—å£ï¼‰');
                        }

                        closeCount += 1;
                        GM_setValue('NiceFont_closeCount', closeCount);
                        GM_setValue('NiceFont_lastCloseTime', now);
                        log(`é¢æ¿å…³é—­ï¼ˆæ— é…ç½®æºï¼‰: closeCount=${closeCount}, lastCloseTime=${now}`);

                        if (closeCount >= CLOSE_COUNT_THRESHOLD) {
                            GM_setValue('NiceFont_autoOpenDisabled', true);
                            log('ç¦ç”¨æ— é…ç½®æºè‡ªåŠ¨å¼¹å‡ºï¼ˆè¿ç»­å…³é—­è¾¾åˆ°é˜ˆå€¼ï¼‰');
                        }
                    } else {
                        log('é¢æ¿å…³é—­ï¼ˆæœ‰é…ç½®æºï¼‰');
                    }
                }
                e.stopPropagation();
            }, { capture: false });
        },

        /**
         * æ›´æ–°é¢æ¿å†…å®¹
         */
        updatePanelContent() {
            if (!this.panelCache) {
                log('panelCache ä¸å­˜åœ¨ï¼Œè·³è¿‡æ›´æ–°å†…å®¹');
                return;
            }
            const t = translations[State.get('currentLanguage')] || translations.en;
            const scriptName = GM_info?.script?.name || 'NiceFont';

            // æ›´æ–°æ ‡é¢˜
            const headerDiv = this.panelCache.querySelector('.NiceFont_header > div');
            if (headerDiv) {
                headerDiv.textContent = scriptName;
                log('é¢æ¿æ ‡é¢˜æ›´æ–°ä¸º:', scriptName);
            } else {
                console.error('[NiceFont] æœªæ‰¾åˆ° .NiceFont_header > divï¼Œæ— æ³•æ›´æ–°æ ‡é¢˜');
            }

            // æ›´æ–°å†…å®¹åŒºåŸŸ
            const contentContainer = this.panelCache.querySelector('.NiceFont_content');
            if (contentContainer) {
                contentContainer.innerHTML = this.getCommandsConfig()
                    .filter(cmd => !cmd.tampermonkeyOnly)
                    .map(cmd =>
                        `<div class="action-btn" id="NiceFont_${cmd.id}">${cmd.getText()}</div>`
                    ).join('');
                log('é¢æ¿å†…å®¹æ›´æ–°æˆåŠŸ');
            } else {
                console.error('[NiceFont] æœªæ‰¾åˆ° .NiceFont_contentï¼Œæ— æ³•æ›´æ–°å†…å®¹');
            }
        },

        /**
         * æ›´æ–°æ²¹çŒ´èœå•
         */
        updateTampermonkeyMenu() {
            this.menuHandles.forEach(handle => {
                try {
                    GM_unregisterMenuCommand(handle);
                } catch (e) {
                    console.error('[NiceFont] å–æ¶ˆæ³¨å†Œèœå•å¤±è´¥:', e);
                }
            });
            this.menuHandles = [];
            const commands = State.get('panelType') === 'tampermonkey'
                ? this.getCommandsConfig().filter(cmd => cmd.id !== 'show-panel')
                : this.getCommandsConfig().filter(cmd => ['switch-panel', 'show-panel'].includes(cmd.id));
            commands.forEach(cmd => {
                const handle = GM_registerMenuCommand(cmd.getText(), () => {
                    cmd.action();
                    log(`æ‰§è¡Œæ²¹çŒ´èœå•å‘½ä»¤: ${cmd.id}`);
                }, { autoClose: cmd.autoClose });
                this.menuHandles.push(handle);
                log(`æ³¨å†Œèœå•: ${cmd.id}`);
            });
        },

        /**
         * æ˜¾ç¤º/éšè—é¢æ¿
         */
        togglePanel() {
            if (State.get('panelType') !== 'floating') {
                log('éæµ®åŠ¨é¢æ¿æ¨¡å¼ï¼Œå¿½ç•¥ togglePanel');
                return;
            }
            const now = Date.now();
            if (now - this.lastToggleTime < 300) {
                log('togglePanel é˜²æŠ–ï¼Œå¿½ç•¥å¿«é€Ÿé‡å¤è°ƒç”¨');
                return;
            }
            this.lastToggleTime = now;

            // ç¡®ä¿ DOM å·²å°±ç»ª
            if (!document.body) {
                console.error('[NiceFont] document.body ä¸å¯ç”¨ï¼Œå»¶è¿Ÿ togglePanel');
                return;
            }

            // å¦‚æœ panelCache ä¸å­˜åœ¨æˆ–æœªé™„åŠ åˆ° DOMï¼Œå¼ºåˆ¶åˆ›å»º
            if (!this.panelCache || !document.body.contains(this.panelCache)) {
                log('panelCache ä¸å­˜åœ¨æˆ–æœªé™„åŠ åˆ° DOMï¼Œå°è¯•é‡æ–°åˆ›å»º');
                this.createFloatingPanel();
                if (!this.panelCache) {
                    console.error('[NiceFont] é¢æ¿åˆ›å»ºå¤±è´¥ï¼Œæ£€æŸ¥ createFloatingPanel');
                    return;
                }
            }

            // åˆ‡æ¢æ˜¾ç¤ºçŠ¶æ€
            const isHidden = this.panelCache.style.display === 'none';
            const display = isHidden ? 'block' : 'none';
            this.panelCache.style.display = display;
            this.overlayCache.style.display = display;
            log(`é¢æ¿æ˜¾ç¤ºçŠ¶æ€: ${display}`);

            // å¦‚æœæ˜¾ç¤ºé¢æ¿ï¼Œæ›´æ–°å†…å®¹
            if (display === 'block') {
                this.updatePanelContent();
            }
        },

        /**
         * æ›´æ–°ç•Œé¢
         */
        updateUI() {
            log('è°ƒç”¨ updateUI, panelType:', State.get('panelType'));
            if (State.get('panelType') === 'tampermonkey') {
                this.updateTampermonkeyMenu();
                if (this.panelCache) {
                    this.panelCache.remove();
                    this.overlayCache.remove();
                    this.panelCache = null;
                    this.overlayCache = null;
                    log('ç§»é™¤æµ®åŠ¨é¢æ¿ï¼ˆåˆ‡æ¢åˆ°æ²¹çŒ´èœå•ï¼‰');
                }
            } else {
                this.updateTampermonkeyMenu();
                // å¦‚æœ panelCache å­˜åœ¨ï¼Œæ›´æ–°å†…å®¹ï¼›å¦åˆ™ç­‰å¾… togglePanel åˆ›å»º
                if (this.panelCache && document.body.contains(this.panelCache)) {
                    this.updatePanelContent();
                    log('æ›´æ–°å·²æœ‰é¢æ¿å†…å®¹');
                } else {
                    log('panelCache ä¸å­˜åœ¨ï¼Œç­‰å¾… togglePanel åˆ›å»º');
                }
                const t = translations[State.get('currentLanguage')] || translations.en;
                const saveBtn = this.panelCache?.querySelector('#NiceFont_save-config');
                if (saveBtn) {
                    saveBtn.textContent = `ğŸ’¾ ${State.get('isConfigModified') ? t.saveConfigPending : t.saveConfig}`;
                }
            }
        }
    };

    // --- å¤šè¯­è¨€æ”¯æŒ ---
    // æ”¯æŒçš„å¤šè¯­è¨€ï¼šæ±‰è¯­(zh)ã€è‹±è¯­(en)ã€éŸ©è¯­(ko)ã€æ—¥è¯­(ja)ã€ä¿„è¯­(ru)ã€æ³•è¯­(fr)ã€å¾·è¯­(de)ã€è¥¿ç­ç‰™è¯­(es)ã€è‘¡è„ç‰™è¯­(pt)
    const translations = {
        zh: {
            increase: 'å¢å¤§å­—ä½“',
            decrease: 'å‡å°å­—ä½“',
            reset: 'æ¢å¤å­—ä½“',
            fontSizeAdjustment: 'å­—ä½“å¤§å°è°ƒæ•´',
            setFontFamily: 'å­—ä½“ç±»å‹è°ƒæ•´',
            setFontFamilyPrompt: 'è¯·è¾“å…¥å­—ä½“ç±»å‹',
            supportFontFamily: 'æ”¯æŒçš„å­—ä½“ç±»å‹ï¼š',
            invalidFontFamilyAlert: 'è¯·è¾“å…¥æœ‰æ•ˆçš„å­—ä½“ç±»å‹ï¼',
            firstAdjustmentConfirm: 'è¯·è¾“å…¥é¦–æ¬¡è°ƒæ•´æ—¶é—´ï¼ˆç§’ï¼Œ0è¡¨ç¤ºç¦ç”¨ï¼‰ï¼š',
            firstAdjustmentEnabled: 'é¦–æ¬¡è°ƒæ•´å­—ä½“: âœ”ï¸',
            firstAdjustmentDisabled: 'é¦–æ¬¡è°ƒæ•´å­—ä½“: âœ–ï¸',
            timerPrompt: 'è¯·è¾“å…¥å®šæ—¶è°ƒæ•´é—´éš”ï¼ˆç§’ï¼Œ0è¡¨ç¤ºç¦ç”¨ï¼‰ï¼š',
            timerAdjustmentEnabled: 'å®šæ—¶è°ƒæ•´å­—ä½“: âœ”ï¸',
            timerAdjustmentDisabled: 'å®šæ—¶è°ƒæ•´å­—ä½“: âœ–ï¸',
            dynamicWatchConfirm: 'æ˜¯å¦å¯ç”¨/ç¦ç”¨åŠ¨æ€è°ƒæ•´ï¼Ÿ',
            dynamicAdjustmentEnabled: 'åŠ¨æ€è°ƒæ•´å­—ä½“: âœ”ï¸',
            dynamicAdjustmentDisabled: 'åŠ¨æ€è°ƒæ•´å­—ä½“: âœ–ï¸',
            usageLanguage: 'åˆ‡æ¢èœå•è¯­è¨€',
            switchPanel: 'åˆ‡æ¢èœå•é¢æ¿',
            tampermonkeyPanel: 'æ²¹çŒ´èœå•',
            floatingPanel: 'é¡µé¢èœå•',
            showPanel: 'æ˜¾ç¤ºé¢æ¿',
            configScope: 'é…ç½®ä½œç”¨èŒƒå›´',
            subdomain: 'å­åŸŸå',
            topLevelDomain: 'é¡¶çº§åŸŸå',
            allWebsites: 'æ‰€æœ‰ç½‘ç«™',
            configScopePrompt: 'è¯·è¾“å…¥é…ç½®ä½œç”¨èŒƒå›´ï¼š\n1: å­åŸŸå ({hostname})\n2: é¡¶çº§åŸŸå ({tld})\n3: æ‰€æœ‰ç½‘ç«™\nå½“å‰èŒƒå›´: {scope}',
            invalidInput: 'è¯·è¾“å…¥æœ‰æ•ˆçš„èŒƒå›´ï¼ˆ1, 2ï¼Œ æˆ– 3ï¼‰ï¼',
            currentConfigScope: 'å½“å‰é…ç½®æºäº',
            notConfigured: 'æœªé…ç½®',
            saveConfig: 'ä¿å­˜é…ç½®',
            saveConfigPending: 'ä¿å­˜é…ç½®ï¼ˆéœ€ç¡®å®šï¼‰',
            saveConfigConfirm: 'ç¡®å®šä¿å­˜é…ç½®åˆ°ï¼š{scope} [{target}]ï¼Ÿ',
            deleteConfigConfirm: 'ç¡®å®šåˆ é™¤å½“å‰é…ç½®å—ï¼Ÿï¼ˆå°†åˆ é™¤ï¼š{scope} [{target}]ï¼‰',
            deleteBeforeScopeChangeConfirm: 'æ›´æ”¹ä¸ºæ›´å¹¿çš„ä½œç”¨èŒƒå›´éœ€è¦å…ˆåˆ é™¤å½“å‰é…ç½®ã€‚\nç¡®å®šåˆ é™¤å½“å‰é…ç½®å—ï¼Ÿï¼ˆå°†åˆ é™¤ï¼š{scope} [{target}]ï¼‰'
        },
        en: {
            increase: 'Increase Font',
            decrease: 'Decrease Font',
            reset: 'Reset Font',
            fontSizeAdjustment: 'Font Size Adjustment',
            setFontFamily: 'Set Font Family',
            setFontFamilyPrompt: 'Enter font family',
            supportFontFamily: 'Supported font families:',
            invalidFontFamilyAlert: 'Please enter a valid font family!',
            firstAdjustmentConfirm: 'Enter first adjustment time (seconds, 0 to disable):',
            firstAdjustmentEnabled: 'First Font Adjustment: âœ”ï¸',
            firstAdjustmentDisabled: 'First Font Adjustment: âœ–ï¸',
            timerPrompt: 'Enter timer adjustment interval (seconds, 0 to disable):',
            timerAdjustmentEnabled: 'Timer Font Adjustment: âœ”ï¸',
            timerAdjustmentDisabled: 'Timer Font Adjustment: âœ–ï¸',
            dynamicWatchConfirm: 'Enable/Disable dynamic adjustment?',
            dynamicAdjustmentEnabled: 'Dynamic Font Adjustment: âœ”ï¸',
            dynamicAdjustmentDisabled: 'Dynamic Font Adjustment: âœ–ï¸',
            usageLanguage: 'Switch Menu Language',
            switchPanel: 'Switch Menu Panel',
            tampermonkeyPanel: 'Tampermonkey Menu',
            floatingPanel: 'Page Menu',
            showPanel: 'Show Panel',
            configScope: 'Config Scope',
            subdomain: 'Subdomain',
            topLevelDomain: 'Top-Level Domain',
            allWebsites: 'All Websites',
            configScopePrompt: 'Enter config scope:\n1: Subdomain ({hostname})\n2: Top-Level Domain ({tld})\n3: All Websites\nCurrent scope: {scope}',
            invalidInput: 'Please enter a valid scope (1, 2, or 3)!',
            currentConfigScope: 'Current Config Scope',
            notConfigured: 'Not Configured',
            saveConfig: 'Save Config',
            saveConfigPending: 'Save Config (Pending)',
            saveConfigConfirm: 'Save configuration to: {scope} [{target}]?',
            deleteConfigConfirm: 'Are you sure to delete the current configuration? (Will delete: {scope} [{target}])',
            deleteBeforeScopeChangeConfirm: 'Changing to a broader scope requires deleting the current configuration.\nAre you sure to delete the current configuration? (Will delete: {scope} [{target}])'
        },
        ko: {
            increase: 'ê¸€ê¼´ í™•ëŒ€',
            decrease: 'ê¸€ê¼´ ì¶•ì†Œ',
            reset: 'ê¸€ê¼´ ì´ˆê¸°í™”',
            fontSizeAdjustment: 'ê¸€ê¼´ í¬ê¸° ì¡°ì •',
            setFontFamily: 'ê¸€ê¼´ ì„¤ì •',
            setFontFamilyPrompt: 'ê¸€ê¼´ì„ ì…ë ¥í•˜ì„¸ìš”',
            supportFontFamily: 'ì§€ì›ë˜ëŠ” ê¸€ê¼´:',
            invalidFontFamilyAlert: 'ìœ íš¨í•œ ê¸€ê¼´ì„ ì…ë ¥í•˜ì„¸ìš”!',
            firstAdjustmentConfirm: 'ì²« ì¡°ì • ì‹œê°„ ì…ë ¥ (ì´ˆ, 0ì€ ë¹„í™œì„±í™”):',
            firstAdjustmentEnabled: 'ì²« ê¸€ê¼´ ì¡°ì •: âœ”ï¸',
            firstAdjustmentDisabled: 'ì²« ê¸€ê¼´ ì¡°ì •: âœ–ï¸',
            timerPrompt: 'íƒ€ì´ë¨¸ ì¡°ì • ê°„ê²© ì…ë ¥ (ì´ˆ, 0ì€ ë¹„í™œì„±í™”):',
            timerAdjustmentEnabled: 'íƒ€ì´ë¨¸ ê¸€ê¼´ ì¡°ì •: âœ”ï¸',
            timerAdjustmentDisabled: 'íƒ€ì´ë¨¸ ê¸€ê¼´ ì¡°ì •: âœ–ï¸',
            dynamicWatchConfirm: 'ë™ì  ì¡°ì •ì„ í™œì„±í™”/ë¹„í™œì„±í™” í•˜ì‹œê² ìŠµë‹ˆê¹Œ?',
            dynamicAdjustmentEnabled: 'ë™ì  ê¸€ê¼´ ì¡°ì •: âœ”ï¸',
            dynamicAdjustmentDisabled: 'ë™ì  ê¸€ê¼´ ì¡°ì •: âœ–ï¸',
            usageLanguage: 'ë©”ë‰´ ì–¸ì–´ ì „í™˜',
            switchPanel: 'ë©”ë‰´ íŒ¨ë„ ì „í™˜',
            tampermonkeyPanel: 'íƒ¬í¼ëª½í‚¤ ë©”ë‰´',
            floatingPanel: 'í˜ì´ì§€ ë©”ë‰´',
            showPanel: 'íŒ¨ë„ í‘œì‹œ',
            configScope: 'ì„¤ì • ë²”ìœ„',
            subdomain: 'ì„œë¸Œë„ë©”ì¸',
            topLevelDomain: 'ìµœìƒìœ„ ë„ë©”ì¸',
            allWebsites: 'ëª¨ë“  ì›¹ì‚¬ì´íŠ¸',
            configScopePrompt: 'ì„¤ì • ë²”ìœ„ë¥¼ ì…ë ¥í•˜ì„¸ìš”:\n1: ì„œë¸Œë„ë©”ì¸ ({hostname})\n2: ìµœìƒìœ„ ë„ë©”ì¸ ({tld})\n3: ëª¨ë“  ì›¹ì‚¬ì´íŠ¸\ní˜„ì¬ ë²”ìœ„: {scope}',
            invalidInput: 'ìœ íš¨í•œ ë²”ìœ„ë¥¼ ì…ë ¥í•˜ì„¸ìš” (1, 2, ë˜ëŠ” 3)!',
            currentConfigScope: 'í˜„ì¬ ì„¤ì • ë²”ìœ„',
            notConfigured: 'ì„¤ì •ë˜ì§€ ì•ŠìŒ',
            saveConfig: 'ì„¤ì • ì €ì¥',
            saveConfigPending: 'ì„¤ì • ì €ì¥ (í™•ì¸ í•„ìš”)',
            saveConfigConfirm: 'ì„¤ì •ì„ ë‹¤ìŒì— ì €ì¥í•˜ì‹œê² ìŠµë‹ˆê¹Œ: {scope} [{target}]?',
            deleteConfigConfirm: 'í˜„ì¬ ì„¤ì •ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ì‚­ì œë  í•­ëª©: {scope} [{target}])',
            deleteBeforeScopeChangeConfirm: 'ë” ë„“ì€ ë²”ìœ„ë¡œ ë³€ê²½í•˜ë ¤ë©´ í˜„ì¬ ì„¤ì •ì„ ì‚­ì œí•´ì•¼ í•©ë‹ˆë‹¤.\ní˜„ì¬ ì„¤ì •ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ì‚­ì œë  í•­ëª©: {scope} [{target}])'
        },
        ja: {
            increase: 'ãƒ•ã‚©ãƒ³ãƒˆã‚’å¤§ããã™ã‚‹',
            decrease: 'ãƒ•ã‚©ãƒ³ãƒˆã‚’å°ã•ãã™ã‚‹',
            reset: 'ãƒ•ã‚©ãƒ³ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ',
            fontSizeAdjustment: 'ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºèª¿æ•´',
            setFontFamily: 'ãƒ•ã‚©ãƒ³ãƒˆãƒ•ã‚¡ãƒŸãƒªãƒ¼è¨­å®š',
            setFontFamilyPrompt: 'ãƒ•ã‚©ãƒ³ãƒˆãƒ•ã‚¡ãƒŸãƒªãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„',
            supportFontFamily: 'ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ãƒ•ã‚©ãƒ³ãƒˆãƒ•ã‚¡ãƒŸãƒªãƒ¼ï¼š',
            invalidFontFamilyAlert: 'æœ‰åŠ¹ãªãƒ•ã‚©ãƒ³ãƒˆãƒ•ã‚¡ãƒŸãƒªãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼',
            firstAdjustmentConfirm: 'åˆå›èª¿æ•´æ™‚é–“ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆç§’ã€0ã§ç„¡åŠ¹ï¼‰ï¼š',
            firstAdjustmentEnabled: 'åˆå›ãƒ•ã‚©ãƒ³ãƒˆèª¿æ•´ï¼šâœ”ï¸',
            firstAdjustmentDisabled: 'åˆå›ãƒ•ã‚©ãƒ³ãƒˆèª¿æ•´ï¼šâœ–ï¸',
            timerPrompt: 'ã‚¿ã‚¤ãƒãƒ¼èª¿æ•´é–“éš”ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆç§’ã€0ã§ç„¡åŠ¹ï¼‰ï¼š',
            timerAdjustmentEnabled: 'ã‚¿ã‚¤ãƒãƒ¼ãƒ•ã‚©ãƒ³ãƒˆèª¿æ•´ï¼šâœ”ï¸',
            timerAdjustmentDisabled: 'ã‚¿ã‚¤ãƒãƒ¼ãƒ•ã‚©ãƒ³ãƒˆèª¿æ•´ï¼šâœ–ï¸',
            dynamicWatchConfirm: 'å‹•çš„èª¿æ•´ã‚’æœ‰åŠ¹/ç„¡åŠ¹ã«ã—ã¾ã™ã‹ï¼Ÿ',
            dynamicAdjustmentEnabled: 'å‹•çš„ãƒ•ã‚©ãƒ³ãƒˆèª¿æ•´ï¼šâœ”ï¸',
            dynamicAdjustmentDisabled: 'å‹•çš„ãƒ•ã‚©ãƒ³ãƒˆèª¿æ•´ï¼šâœ–ï¸',
            usageLanguage: 'ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¨€èªã®åˆ‡ã‚Šæ›¿ãˆ',
            switchPanel: 'ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒ‘ãƒãƒ«ã®åˆ‡ã‚Šæ›¿ãˆ',
            tampermonkeyPanel: 'Tampermonkeyãƒ¡ãƒ‹ãƒ¥ãƒ¼',
            floatingPanel: 'ãƒšãƒ¼ã‚¸ãƒ¡ãƒ‹ãƒ¥ãƒ¼',
            showPanel: 'ãƒ‘ãƒãƒ«ã‚’è¡¨ç¤º',
            configScope: 'è¨­å®šç¯„å›²',
            subdomain: 'ã‚µãƒ–ãƒ‰ãƒ¡ã‚¤ãƒ³',
            topLevelDomain: 'ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ãƒ‰ãƒ¡ã‚¤ãƒ³',
            allWebsites: 'ã™ã¹ã¦ã®ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆ',
            configScopePrompt: 'è¨­å®šç¯„å›²ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼š\n1: ã‚µãƒ–ãƒ‰ãƒ¡ã‚¤ãƒ³ ({hostname})\n2: ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ãƒ‰ãƒ¡ã‚¤ãƒ³ ({tld})\n3: ã™ã¹ã¦ã®ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆ\nç¾åœ¨ã®ç¯„å›²: {scope}',
            invalidInput: 'æœ‰åŠ¹ãªç¯„å›²ï¼ˆ1ã€2ã€ã¾ãŸã¯3ï¼‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼',
            currentConfigScope: 'ç¾åœ¨ã®è¨­å®šç¯„å›²',
            notConfigured: 'æœªè¨­å®š',
            saveConfig: 'è¨­å®šã‚’ä¿å­˜',
            saveConfigPending: 'è¨­å®šã‚’ä¿å­˜ï¼ˆç¢ºèªãŒå¿…è¦ï¼‰',
            saveConfigConfirm: 'è¨­å®šã‚’ä¿å­˜ã—ã¾ã™ã‹ï¼š{scope} [{target}]ï¼Ÿ',
            deleteConfigConfirm: 'ç¾åœ¨ã®è¨­å®šã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿï¼ˆå‰Šé™¤å¯¾è±¡ï¼š{scope} [{target}]ï¼‰',
            deleteBeforeScopeChangeConfirm: 'ã‚ˆã‚Šåºƒã„ç¯„å›²ã«å¤‰æ›´ã™ã‚‹ã«ã¯ã€ç¾åœ¨ã®è¨­å®šã‚’å‰Šé™¤ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚\nç¾åœ¨ã®è¨­å®šã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿï¼ˆå‰Šé™¤å¯¾è±¡ï¼š{scope} [{target}]ï¼‰'
        },
        ru: {
            increase: 'Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ñ‚ÑŒ ÑˆÑ€Ğ¸Ñ„Ñ‚',
            decrease: 'Ğ£Ğ¼ĞµĞ½ÑŒÑˆĞ¸Ñ‚ÑŒ ÑˆÑ€Ğ¸Ñ„Ñ‚',
            reset: 'Ğ¡Ğ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ ÑˆÑ€Ğ¸Ñ„Ñ‚',
            fontSizeAdjustment: 'Ğ ĞµĞ³ÑƒĞ»Ğ¸Ñ€Ğ¾Ğ²ĞºĞ° Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ° ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ°',
            setFontFamily: 'Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ ÑĞµĞ¼ĞµĞ¹ÑÑ‚Ğ²Ğ¾ ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ¾Ğ²',
            setFontFamilyPrompt: 'Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ÑĞµĞ¼ĞµĞ¹ÑÑ‚Ğ²Ğ¾ ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ¾Ğ²',
            supportFontFamily: 'ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµĞ¼Ñ‹Ğµ ÑĞµĞ¼ĞµĞ¹ÑÑ‚Ğ²Ğ° ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ¾Ğ²:',
            invalidFontFamilyAlert: 'ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğµ ÑĞµĞ¼ĞµĞ¹ÑÑ‚Ğ²Ğ¾ ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ¾Ğ²!',
            firstAdjustmentConfirm: 'Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ²Ñ€ĞµĞ¼Ñ Ğ¿ĞµÑ€Ğ²Ğ¾Ğ¹ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ (ÑĞµĞºÑƒĞ½Ğ´Ñ‹, 0 Ğ´Ğ»Ñ Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ):',
            firstAdjustmentEnabled: 'ĞŸĞµÑ€Ğ²Ğ°Ñ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ°: âœ”ï¸',
            firstAdjustmentDisabled: 'ĞŸĞµÑ€Ğ²Ğ°Ñ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ°: âœ–ï¸',
            timerPrompt: 'Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ» Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€Ğ° Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ (ÑĞµĞºÑƒĞ½Ğ´Ñ‹, 0 Ğ´Ğ»Ñ Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ):',
            timerAdjustmentEnabled: 'ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ° Ğ¿Ğ¾ Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€Ñƒ: âœ”ï¸',
            timerAdjustmentDisabled: 'ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ° Ğ¿Ğ¾ Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€Ñƒ: âœ–ï¸',
            dynamicWatchConfirm: 'Ğ’ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ/Ğ¾Ñ‚ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ´Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºÑƒÑ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºÑƒ?',
            dynamicAdjustmentEnabled: 'Ğ”Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ°: âœ”ï¸',
            dynamicAdjustmentDisabled: 'Ğ”Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ°: âœ–ï¸',
            usageLanguage: 'ĞŸĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ ÑĞ·Ñ‹Ğº Ğ¼ĞµĞ½Ñ',
            switchPanel: 'ĞŸĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ Ğ¼ĞµĞ½Ñ',
            tampermonkeyPanel: 'ĞœĞµĞ½Ñ Tampermonkey',
            floatingPanel: 'ĞœĞµĞ½Ñ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ñ‹',
            showPanel: 'ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ',
            configScope: 'ĞĞ±Ğ»Ğ°ÑÑ‚ÑŒ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ğ¸',
            subdomain: 'Ğ¡ÑƒĞ±Ğ´Ğ¾Ğ¼ĞµĞ½',
            topLevelDomain: 'Ğ”Ğ¾Ğ¼ĞµĞ½ Ğ²ĞµÑ€Ñ…Ğ½ĞµĞ³Ğ¾ ÑƒÑ€Ğ¾Ğ²Ğ½Ñ',
            allWebsites: 'Ğ’ÑĞµ Ğ²ĞµĞ±-ÑĞ°Ğ¹Ñ‚Ñ‹',
            configScopePrompt: 'Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ğ¸:\n1: Ğ¡ÑƒĞ±Ğ´Ğ¾Ğ¼ĞµĞ½ ({hostname})\n2: Ğ”Ğ¾Ğ¼ĞµĞ½ Ğ²ĞµÑ€Ñ…Ğ½ĞµĞ³Ğ¾ ÑƒÑ€Ğ¾Ğ²Ğ½Ñ ({tld})\n3: Ğ’ÑĞµ Ğ²ĞµĞ±-ÑĞ°Ğ¹Ñ‚Ñ‹\nĞ¢ĞµĞºÑƒÑ‰Ğ°Ñ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ: {scope}',
            invalidInput: 'ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ‚ĞµĞ»ÑŒĞ½ÑƒÑ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ (1, 2 Ğ¸Ğ»Ğ¸ 3)!',
            currentConfigScope: 'Ğ¢ĞµĞºÑƒÑ‰Ğ°Ñ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ğ¸',
            notConfigured: 'ĞĞµ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ¾',
            saveConfig: 'Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ',
            saveConfigPending: 'Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ (Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµÑ‚ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ)',
            saveConfigConfirm: 'Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ Ğ²: {scope} [{target}]?',
            deleteConfigConfirm: 'Ğ’Ñ‹ ÑƒĞ²ĞµÑ€ĞµĞ½Ñ‹, Ñ‡Ñ‚Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ? (Ğ‘ÑƒĞ´ĞµÑ‚ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¾: {scope} [{target}])',
            deleteBeforeScopeChangeConfirm: 'Ğ”Ğ»Ñ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ Ğ½Ğ° Ğ±Ğ¾Ğ»ĞµĞµ ÑˆĞ¸Ñ€Ğ¾ĞºÑƒÑ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ.\nĞ’Ñ‹ ÑƒĞ²ĞµÑ€ĞµĞ½Ñ‹, Ñ‡Ñ‚Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ? (Ğ‘ÑƒĞ´ĞµÑ‚ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¾: {scope} [{target}])'
        },
        fr: {
            increase: 'Augmenter la police',
            decrease: 'RÃ©duire la police',
            reset: 'RÃ©initialiser la police',
            fontSizeAdjustment: 'Ajustement de la taille de la police',
            setFontFamily: 'DÃ©finir la famille de polices',
            setFontFamilyPrompt: 'Entrez la famille de polices',
            supportFontFamily: 'Familles de polices prises en charge :',
            invalidFontFamilyAlert: 'Veuillez entrer une famille de polices valide !',
            firstAdjustmentConfirm: 'Entrez le temps du premier ajustement (secondes, 0 pour dÃ©sactiver) :',
            firstAdjustmentEnabled: 'Premier ajustement de police : âœ”ï¸',
            firstAdjustmentDisabled: 'Premier ajustement de police : âœ–ï¸',
            timerPrompt: 'Entrez lâ€™intervalle dâ€™ajustement du minuteur (secondes, 0 pour dÃ©sactiver) :',
            timerAdjustmentEnabled: 'Ajustement de police par minuteur : âœ”ï¸',
            timerAdjustmentDisabled: 'Ajustement de police par minuteur : âœ–ï¸',
            dynamicWatchConfirm: 'Activer/dÃ©sactiver lâ€™ajustement dynamique ?',
            dynamicAdjustmentEnabled: 'Ajustement dynamique de la police : âœ”ï¸',
            dynamicAdjustmentDisabled: 'Ajustement dynamique de la police : âœ–ï¸',
            usageLanguage: 'Changer la langue du menu',
            switchPanel: 'Changer de panneau de menu',
            tampermonkeyPanel: 'Menu Tampermonkey',
            floatingPanel: 'Menu de la page',
            showPanel: 'Afficher le panneau',
            configScope: 'PortÃ©e de la configuration',
            subdomain: 'Sous-domaine',
            topLevelDomain: 'Domaine de premier niveau',
            allWebsites: 'Tous les sites web',
            configScopePrompt: 'Entrez la portÃ©e de la configuration :\n1 : Sous-domaine ({hostname})\n2 : Domaine de premier niveau ({tld})\n3 : Tous les sites web\nPortÃ©e actuelle : {scope}',
            invalidInput: 'Veuillez entrer une portÃ©e valide (1, 2 ou 3) !',
            currentConfigScope: 'PortÃ©e de configuration actuelle',
            notConfigured: 'Non configurÃ©',
            saveConfig: 'Enregistrer la configuration',
            saveConfigPending: 'Enregistrer la configuration (en attente)',
            saveConfigConfirm: 'Enregistrer la configuration dans : {scope} [{target}] ?',
            deleteConfigConfirm: 'ÃŠtes-vous sÃ»r de vouloir supprimer la configuration actuelle ? (Supprimera : {scope} [{target}])',
            deleteBeforeScopeChangeConfirm: 'Changer pour une portÃ©e plus large nÃ©cessite de supprimer la configuration actuelle.\nÃŠtes-vous sÃ»r de vouloir supprimer la configuration actuelle ? (Supprimera : {scope} [{target}])'
        },
        de: {
            increase: 'Schriftart vergrÃ¶ÃŸern',
            decrease: 'Schriftart verkleinern',
            reset: 'Schriftart zurÃ¼cksetzen',
            fontSizeAdjustment: 'SchriftgrÃ¶ÃŸenanpassung',
            setFontFamily: 'Schriftfamilie festlegen',
            setFontFamilyPrompt: 'Geben Sie die Schriftfamilie ein',
            supportFontFamily: 'UnterstÃ¼tzte Schriftfamilien:',
            invalidFontFamilyAlert: 'Bitte geben Sie eine gÃ¼ltige Schriftfamilie ein!',
            firstAdjustmentConfirm: 'Geben Sie die Zeit fÃ¼r die erste Anpassung ein (Sekunden, 0 zum Deaktivieren):',
            firstAdjustmentEnabled: 'Erste Schrifteinstellung: âœ”ï¸',
            firstAdjustmentDisabled: 'Erste Schrifteinstellung: âœ–ï¸',
            timerPrompt: 'Geben Sie das Intervall fÃ¼r die Timer-Anpassung ein (Sekunden, 0 zum Deaktivieren):',
            timerAdjustmentEnabled: 'Timer-Schrifteinstellung: âœ”ï¸',
            timerAdjustmentDisabled: 'Timer-Schrifteinstellung: âœ–ï¸',
            dynamicWatchConfirm: 'Dynamische Anpassung aktivieren/deaktivieren?',
            dynamicAdjustmentEnabled: 'Dynamische Schrifteinstellung: âœ”ï¸',
            dynamicAdjustmentDisabled: 'Dynamische Schrifteinstellung: âœ–ï¸',
            usageLanguage: 'MenÃ¼sprache wechseln',
            switchPanel: 'MenÃ¼panel wechseln',
            tampermonkeyPanel: 'Tampermonkey-MenÃ¼',
            floatingPanel: 'SeitenmenÃ¼',
            showPanel: 'Panel anzeigen',
            configScope: 'Konfigurationsbereich',
            subdomain: 'Subdomain',
            topLevelDomain: 'Top-Level-Domain',
            allWebsites: 'Alle Websites',
            configScopePrompt: 'Geben Sie den Konfigurationsbereich ein:\n1: Subdomain ({hostname})\n2: Top-Level-Domain ({tld})\n3: Alle Websites\nAktueller Bereich: {scope}',
            invalidInput: 'Bitte geben Sie einen gÃ¼ltigen Bereich ein (1, 2 oder 3)!',
            currentConfigScope: 'Aktueller Konfigurationsbereich',
            notConfigured: 'Nicht konfiguriert',
            saveConfig: 'Konfiguration speichern',
            saveConfigPending: 'Konfiguration speichern (ausstehend)',
            saveConfigConfirm: 'Konfiguration speichern in: {scope} [{target}]?',
            deleteConfigConfirm: 'MÃ¶chten Sie die aktuelle Konfiguration wirklich lÃ¶schen? (Wird gelÃ¶scht: {scope} [{target}])',
            deleteBeforeScopeChangeConfirm: 'Zum Wechseln zu einem breiteren Bereich muss die aktuelle Konfiguration gelÃ¶scht werden.\nMÃ¶chten Sie die aktuelle Konfiguration wirklich lÃ¶schen? (Wird gelÃ¶scht: {scope} [{target}])'
        },
        es: {
            increase: 'Aumentar fuente',
            decrease: 'Reducir fuente',
            reset: 'Restablecer fuente',
            fontSizeAdjustment: 'Ajuste del tamaÃ±o de fuente',
            setFontFamily: 'Establecer familia de fuentes',
            setFontFamilyPrompt: 'Ingrese la familia de fuentes',
            supportFontFamily: 'Familias de fuentes compatibles:',
            invalidFontFamilyAlert: 'Â¡Por favor, ingrese una familia de fuentes vÃ¡lida!',
            firstAdjustmentConfirm: 'Ingrese el tiempo del primer ajuste (segundos, 0 para desactivar):',
            firstAdjustmentEnabled: 'Primer ajuste de fuente: âœ”ï¸',
            firstAdjustmentDisabled: 'Primer ajuste de fuente: âœ–ï¸',
            timerPrompt: 'Ingrese el intervalo de ajuste del temporizador (segundos, 0 para desactivar):',
            timerAdjustmentEnabled: 'Ajuste de fuente por temporizador: âœ”ï¸',
            timerAdjustmentDisabled: 'Ajuste de fuente por temporizador: âœ–ï¸',
            dynamicWatchConfirm: 'Â¿Activar/desactivar el ajuste dinÃ¡mico?',
            dynamicAdjustmentEnabled: 'Ajuste dinÃ¡mico de fuente: âœ”ï¸',
            dynamicAdjustmentDisabled: 'Ajuste dinÃ¡mico de fuente: âœ–ï¸',
            usageLanguage: 'Cambiar idioma del menÃº',
            switchPanel: 'Cambiar panel del menÃº',
            tampermonkeyPanel: 'MenÃº de Tampermonkey',
            floatingPanel: 'MenÃº de pÃ¡gina',
            showPanel: 'Mostrar panel',
            configScope: 'Alcance de la configuraciÃ³n',
            subdomain: 'Subdominio',
            topLevelDomain: 'Dominio de nivel superior',
            allWebsites: 'Todos los sitios web',
            configScopePrompt: 'Ingrese el alcance de la configuraciÃ³n:\n1: Subdominio ({hostname})\n2: Dominio de nivel superior ({tld})\n3: Todos los sitios web\nAlcance actual: {scope}',
            invalidInput: 'Â¡Por favor, ingrese un alcance vÃ¡lido (1, 2 o 3)!',
            currentConfigScope: 'Alcance de configuraciÃ³n actual',
            notConfigured: 'No configurado',
            saveConfig: 'Guardar configuraciÃ³n',
            saveConfigPending: 'Guardar configuraciÃ³n (pendiente)',
            saveConfigConfirm: 'Â¿Guardar configuraciÃ³n en: {scope} [{target}]?',
            deleteConfigConfirm: 'Â¿EstÃ¡ seguro de que desea eliminar la configuraciÃ³n actual? (Se eliminarÃ¡: {scope} [{target}])',
            deleteBeforeScopeChangeConfirm: 'Cambiar a un alcance mÃ¡s amplio requiere eliminar la configuraciÃ³n actual.\nÂ¿EstÃ¡ seguro de que desea eliminar la configuraciÃ³n actual? (Se eliminarÃ¡: {scope} [{target}])'
        },
        pt: {
            increase: 'Aumentar fonte',
            decrease: 'Diminuir fonte',
            reset: 'Redefinir fonte',
            fontSizeAdjustment: 'Ajuste do tamanho da fonte',
            setFontFamily: 'Definir famÃ­lia de fontes',
            setFontFamilyPrompt: 'Digite a famÃ­lia de fontes',
            supportFontFamily: 'FamÃ­lias de fontes suportadas:',
            invalidFontFamilyAlert: 'Por favor, insira uma famÃ­lia de fontes vÃ¡lida!',
            firstAdjustmentConfirm: 'Digite o tempo do primeiro ajuste (segundos, 0 para desativar):',
            firstAdjustmentEnabled: 'Primeiro ajuste de fonte: âœ”ï¸',
            firstAdjustmentDisabled: 'Primeiro ajuste de fonte: âœ–ï¸',
            timerPrompt: 'Digite o intervalo de ajuste do temporizador (segundos, 0 para desativar):',
            timerAdjustmentEnabled: 'Ajuste de fonte por temporizador: âœ”ï¸',
            timerAdjustmentDisabled: 'Ajuste de fonte por temporizador: âœ–ï¸',
            dynamicWatchConfirm: 'Ativar/desativar ajuste dinÃ¢mico?',
            dynamicAdjustmentEnabled: 'Ajuste dinÃ¢mico de fonte: âœ”ï¸',
            dynamicAdjustmentDisabled: 'Ajuste dinÃ¢mico de fonte: âœ–ï¸',
            usageLanguage: 'Mudar idioma do menu',
            switchPanel: 'Mudar painel do menu',
            tampermonkeyPanel: 'Menu Tampermonkey',
            floatingPanel: 'Menu da pÃ¡gina',
            showPanel: 'Mostrar painel',
            configScope: 'Escopo da configuraÃ§Ã£o',
            subdomain: 'SubdomÃ­nio',
            topLevelDomain: 'DomÃ­nio de nÃ­vel superior',
            allWebsites: 'Todos os sites',
            configScopePrompt: 'Digite o escopo da configuraÃ§Ã£o:\n1: SubdomÃ­nio ({hostname})\n2: DomÃ­nio de nÃ­vel superior ({tld})\n3: Todos os sites\nEscopo atual: {scope}',
            invalidInput: 'Por favor, insira um escopo vÃ¡lido (1, 2 ou 3)!',
            currentConfigScope: 'Escopo de configuraÃ§Ã£o atual',
            notConfigured: 'NÃ£o configurado',
            saveConfig: 'Salvar configuraÃ§Ã£o',
            saveConfigPending: 'Salvar configuraÃ§Ã£o (pendente)',
            saveConfigConfirm: 'Salvar configuraÃ§Ã£o em: {scope} [{target}]?',
            deleteConfigConfirm: 'Tem certeza de que deseja excluir a configuraÃ§Ã£o atual? (SerÃ¡ excluÃ­do: {scope} [{target}])',
            deleteBeforeScopeChangeConfirm: 'Mudar para um escopo mais amplo exige a exclusÃ£o da configuraÃ§Ã£o atual.\nTem certeza de que deseja excluir a configuraÃ§Ã£o atual? (SerÃ¡ excluÃ­do: {scope} [{target}])'
        }
    };

    // --- CSS æ ·å¼ ---
    GM_addStyle(`
        #NiceFont_panel {
            position: fixed;
            width: 300px;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 10001;
            font-family: sans-serif !important;
            font-size: 15px;
            user-select: none;
        }
        #NiceFont_panel .NiceFont_header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
            z-index: 10002;
        }
        #NiceFont_panel .NiceFont_header > div {
            font-size: 16px !important;
            font-family: sans-serif !important;
            text-align: left;
            flex-grow: 1;
            cursor: grab;
            margin: 5px;
            font-weight: bold;
        }
        #NiceFont_panel .NiceFont_close-btn {
            border: none;
            border-radius: 3px;
            padding: 1px 6px;
            cursor: pointer;
            line-height: 16px;
            font-size: 12px;
            background: none;
            color: #000;
        }
        #NiceFont_panel .NiceFont_close-btn:hover {
            text-decoration: underline;
        }
        #NiceFont_panel .action-btn {
            display: block;
            padding: 2px;
            border-radius: 3px;
            cursor: pointer;
            text-align: left;
        }
        #NiceFont_panel .action-btn:hover {
            text-decoration: underline;
        }
        #NiceFont_panel #NiceFont_set-font-size-btn {
            padding: 2px;
            text-decoration: none !important;
        }
        #NiceFont_panel .font-family-select {
            display: inline-block;
            width: auto;
            padding: 2px;
            margin-left: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 14px;
            vertical-align: middle;
        }
    `);

    // --- åˆå§‹åŒ– ---
    /**
     * åˆå§‹åŒ–è„šæœ¬
     */
    function init() {
        // æ£€æŸ¥æ—§ç‰ˆæœ¬å­˜å‚¨æ•°æ®å¹¶æ¸…ç†ï¼ˆç”¨äºå‡çº§å…¼å®¹ï¼‰
        const oldVersion = GM_getValue('NiceFont_version', '0.0');
        const currentVersion = GM_info?.script?.version;
        if (oldVersion !== currentVersion) {
            // æ¸…ç†å¯èƒ½å¯¼è‡´å†²çªçš„æ—§å­˜å‚¨
            GM_setValue('NiceFont_autoOpenDisabled', false);
            GM_setValue('NiceFont_closeCount', 0);
            GM_setValue('NiceFont_lastCloseTime', 0);
            GM_setValue('NiceFont_autoShowAfterLanguageSwitch', true); // é»˜è®¤å¯ç”¨è‡ªåŠ¨æ˜¾ç¤º
            GM_setValue('NiceFont_version', currentVersion);
            log(`æ£€æµ‹åˆ°ç‰ˆæœ¬å‡çº§: ${oldVersion} -> ${currentVersion}ï¼Œæ¸…ç†æ—§å­˜å‚¨æ•°æ®`);
        }

        // åˆå§‹åŒ–è¯­è¨€
        let lang = GM_getValue('language', navigator.language);
        if (!translations[lang]) {
            lang = lang.startsWith('zh') ? 'zh' : 'en';
            GM_setValue('language', lang);
        }
        State.set('currentLanguage', lang);
        log(`è¯­è¨€è®¾ç½®ä¸º: ${lang}`);

        // åˆå§‹åŒ–é¢æ¿ç±»å‹
        let panelType = GM_getValue(ConfigScopeManager.PANEL_TYPE_KEY, 'floating');
        State.set('panelType', panelType);
        log(`é¢æ¿ç±»å‹è®¾ç½®ä¸º: ${panelType}`);

        // åŠ è½½é…ç½®
        ConfigManager.loadConfig();

        // åˆå§‹åŒ–ç•Œé¢
        UIManager.updateUI();

        // å»¶è¿Ÿåˆ›å»ºæµ®åŠ¨é¢æ¿ï¼Œç›´åˆ° DOM å°±ç»ª
        function initializePanel() {
            if (State.get('panelType') === 'floating' && (!UIManager.panelCache || !document.body.contains(UIManager.panelCache))) {
                UIManager.createFloatingPanel();
                if (UIManager.panelCache) {
                    UIManager.panelCache.style.display = 'none';
                    UIManager.overlayCache.style.display = 'none';
                    log('é¦–æ¬¡åˆå§‹åŒ–æµ®åŠ¨é¢æ¿ï¼Œè®¾ç½®ä¸ºéšè—çŠ¶æ€');
                } else {
                    console.error('[NiceFont] åˆå§‹åˆ›å»ºæµ®åŠ¨é¢æ¿å¤±è´¥');
                }
            }
        }

        if (document.body) {
            initializePanel();
        } else {
            document.addEventListener('DOMContentLoaded', initializePanel, { once: true });
            log('document.body æœªå°±ç»ªï¼Œå»¶è¿Ÿé¢æ¿åˆå§‹åŒ–è‡³ DOMContentLoaded');
        }

        // åˆå§‹åŒ–å­—ä½“è°ƒæ•´
        window.addEventListener('load', () => {
            if (State.get('currentAdjustment') !== 0 || State.get('currentFontFamily') !== 'none') {
                if (State.get('firstAdjustment') && State.get('firstAdjustmentTime') > 0) {
                    setTimeout(() => {
                        FontManager.applyFontRecursively(document.body, State.get('currentAdjustment'));
                        log('åº”ç”¨é¦–æ¬¡å­—ä½“è°ƒæ•´');
                    }, State.get('firstAdjustmentTime') * 1000);
                }
                if (State.get('watchDOMChanges')) {
                    if (State.get('timer')) clearInterval(State.get('timer'));
                    const nodeCount = document.body.getElementsByTagName('*').length;
                    const throttleTime = nodeCount > 10000 ? 200 : 100;
                    State.set('observer', new MutationObserver(Utils.throttle(() => {
                        FontManager.applyFontRecursively(document.body, State.get('currentAdjustment'));
                    }, throttleTime)));
                    State.get('observer').observe(document.body, { childList: true, subtree: true });
                    log('åŠ¨æ€è°ƒæ•´å¯ç”¨');
                } else if (State.get('intervalSeconds') > 0) {
                    if (State.get('observer')) State.get('observer').disconnect();
                    State.set('timer', setInterval(() => {
                        FontManager.applyFontRecursively(document.body, State.get('currentAdjustment'));
                    }, State.get('intervalSeconds') * 1000));
                    log(`å®šæ—¶è°ƒæ•´å¯ç”¨: ${State.get('intervalSeconds')}s`);
                }
            }
        });

        log('è„šæœ¬åˆå§‹åŒ–å®Œæˆ');
    }

    init();
})();