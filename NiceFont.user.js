// ==UserScript==
// @name         NiceFont (è€è§†å­—ä½“)
// @name:zh-CN    NiceFont (è€è§†å­—ä½“)
// @name:zh-TW    NiceFontï¼ˆè€è¦–å­—é«”ï¼‰
// @name:en       NiceFont
// @name:ko       NiceFont (ì¢‹ì€ ê¸€ê¼´)
// @name:ja       NiceFont (ã„ã„ãƒ•ã‚©ãƒ³ãƒˆ)
// @name:ru       NiceFont (Ğ¥Ğ¾Ñ€Ğ¾ÑˆĞ¸Ğ¹ ÑˆÑ€Ğ¸Ñ„Ñ‚)
// @name:fr       NiceFont (Police agrÃ©able)
// @name:de       NiceFont (SchÃ¶ne Schrift)
// @name:es       NiceFont (Fuente agradable)
// @name:pt       NiceFont (Fonte agradÃ¡vel)
// @version      3.1
// @author       DD1024z
// @description  NiceFont: æ˜¯ä¸€æ¬¾ä¼˜åŒ–ç½‘é¡µå­—ä½“æ˜¾ç¤ºçš„å¼ºå¤§å·¥å…·ï¼Œè®©æµè§ˆæ›´æ¸…æ™°ã€èˆ’é€‚ï¼â€œçœŸæ­£è°ƒæ•´å­—ä½“ï¼Œè€Œéé¡µé¢ç¼©æ”¾ï¼Œæ‹’ç»å°†å°±â€ï¼å¯ç›´æ¥ä¿®æ”¹ç½‘é¡µçš„å­—ä½“å¤§å°ä¸é£æ ¼ï¼Œä¿å­˜ä½ çš„å­—ä½“è®¾ç½®ï¼Œè½»æ¾åº”ç”¨åˆ°æ¯ä¸ªç½‘é¡µï¼Œæ”¯æŒé¦–æ¬¡ã€å®šæ—¶æˆ–åŠ¨æ€è°ƒæ•´å­—ä½“ï¼Œé€‚é…å­åŸŸåã€æ•´ç«™æˆ–å…¨å±€è®¾ç½®ï¼Œå…¼å®¹Bç«™è¯„è®ºåŒºã€é’‰é’‰æ–‡æ¡£ã€çŸ¥ä¹ã€è®ºå›ç­‰å‡ ä¹æ‰€æœ‰ç½‘ç«™ï¼
// @description:zh-CN  NiceFont: æ˜¯ä¸€æ¬¾ä¼˜åŒ–ç½‘é¡µå­—ä½“æ˜¾ç¤ºçš„å¼ºå¤§å·¥å…·ï¼Œè®©æµè§ˆæ›´æ¸…æ™°ã€èˆ’é€‚ï¼â€œçœŸæ­£è°ƒæ•´å­—ä½“ï¼Œè€Œéé¡µé¢ç¼©æ”¾ï¼Œæ‹’ç»å°†å°±â€ï¼å¯ç›´æ¥ä¿®æ”¹ç½‘é¡µçš„å­—ä½“å¤§å°ä¸é£æ ¼ï¼Œä¿å­˜ä½ çš„å­—ä½“è®¾ç½®ï¼Œè½»æ¾åº”ç”¨åˆ°æ¯ä¸ªç½‘é¡µï¼Œæ”¯æŒé¦–æ¬¡ã€å®šæ—¶æˆ–åŠ¨æ€è°ƒæ•´å­—ä½“ï¼Œé€‚é…å­åŸŸåã€æ•´ç«™æˆ–å…¨å±€è®¾ç½®ï¼Œå…¼å®¹Bç«™è¯„è®ºåŒºã€é’‰é’‰æ–‡æ¡£ã€çŸ¥ä¹ã€è®ºå›ç­‰å‡ ä¹æ‰€æœ‰ç½‘ç«™ï¼
// @description:zh-TW  NiceFontï¼šæ˜¯ä¸€æ¬¾å„ªåŒ–ç¶²é å­—é«”é¡¯ç¤ºçš„å¼·å¤§å·¥å…·ï¼Œè®“ç€è¦½æ›´æ¸…æ™°ã€èˆ’é©ï¼ã€ŒçœŸæ­£èª¿æ•´å­—é«”ï¼Œè€Œéé é¢ç¸®æ”¾ï¼Œæ‹’çµ•å°‡å°±ã€ï¼å¯ç›´æ¥ä¿®æ”¹ç¶²é çš„å­—é«”å¤§å°èˆ‡é¢¨æ ¼ï¼Œå„²å­˜ä½ çš„å­—é«”è¨­å®šï¼Œè¼•é¬†æ‡‰ç”¨åˆ°æ¯å€‹ç¶²é ï¼Œæ”¯æ´é¦–æ¬¡ã€å®šæ™‚æˆ–å‹•æ…‹èª¿æ•´å­—é«”ï¼Œé©é…å­åŸŸåã€æ•´ç«™æˆ–å…¨å±€è¨­å®šï¼Œç›¸å®¹Bç«™è©•è«–å€ã€é‡˜é‡˜æ–‡ä»¶ã€çŸ¥ä¹ã€è«–å£‡ç­‰å¹¾ä¹æ‰€æœ‰ç¶²ç«™ï¼
// @description:en     NiceFont: A powerful tool to optimize web font display for clearer, more comfortable browsing! "Truly adjusts fonts, not page scalingâ€”settle for nothing less!" Directly modifies font size and style, saves your settings, and applies them effortlessly to every page. Supports one-time, scheduled, or dynamic font adjustments, adaptable to subdomains, entire sites, or global settings. Compatible with nearly all websites, including Bilibili comments, DingTalk docs, Zhihu, forums, and more!
// @description:ko     NiceFont: ì›¹ í°íŠ¸ í‘œì‹œë¥¼ ìµœì í™”í•˜ì—¬ ë” ì„ ëª…í•˜ê³  í¸ì•ˆí•œ ë¸Œë¼ìš°ì§•ì„ ì œê³µí•˜ëŠ” ê°•ë ¥í•œ ë„êµ¬! "í˜ì´ì§€ë¥¼ ìŠ¤ì¼€ì¼ë§í•˜ì§€ ì•Šê³  ì§„ì •ìœ¼ë¡œ í°íŠ¸ë¥¼ ì¡°ì •â€”íƒ€í˜‘í•˜ì§€ ë§ˆì„¸ìš”!" í°íŠ¸ í¬ê¸°ì™€ ìŠ¤íƒ€ì¼ì„ ì§ì ‘ ìˆ˜ì •í•˜ê³ , ì„¤ì •ì„ ì €ì¥í•˜ì—¬ ëª¨ë“  í˜ì´ì§€ì— ì‰½ê²Œ ì ìš©í•©ë‹ˆë‹¤. ìµœì´ˆ, ì •ê¸° ë˜ëŠ” ë™ì  í°íŠ¸ ì¡°ì •ì„ ì§€ì›í•˜ë©°, ì„œë¸Œë„ë©”ì¸, ì „ì²´ ì‚¬ì´íŠ¸ ë˜ëŠ” ì „ì—­ ì„¤ì •ì— ì ì‘ ê°€ëŠ¥. Bilibili ëŒ“ê¸€, DingTalk ë¬¸ì„œ, Zhihu, í¬ëŸ¼ ë“± ê±°ì˜ ëª¨ë“  ì›¹ì‚¬ì´íŠ¸ì™€ í˜¸í™˜!
// @description:ja     NiceFontï¼šã‚¦ã‚§ãƒ–ãƒ•ã‚©ãƒ³ãƒˆè¡¨ç¤ºã‚’æœ€é©åŒ–ã—ã€ã‚ˆã‚Šã‚¯ãƒªã‚¢ã§å¿«é©ãªé–²è¦§ã‚’å®Ÿç¾ã™ã‚‹å¼·åŠ›ãªãƒ„ãƒ¼ãƒ«ï¼ã€Œãƒšãƒ¼ã‚¸ã®ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ã§ã¯ãªãã€ãƒ•ã‚©ãƒ³ãƒˆã‚’æœ¬å½“ã®æ„å‘³ã§èª¿æ•´â€”å¦¥å”ã¯ãªã—ï¼ã€ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã¨ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ç›´æ¥å¤‰æ›´ã—ã€è¨­å®šã‚’ä¿å­˜ã—ã¦ã™ã¹ã¦ã®ãƒšãƒ¼ã‚¸ã«ç°¡å˜ã«é©ç”¨ã€‚åˆå›ã€å®šæœŸã€ã¾ãŸã¯å‹•çš„ãƒ•ã‚©ãƒ³ãƒˆèª¿æ•´ã‚’ã‚µãƒãƒ¼ãƒˆã—ã€ã‚µãƒ–ãƒ‰ãƒ¡ã‚¤ãƒ³ã€ã‚µã‚¤ãƒˆå…¨ä½“ã€ã¾ãŸã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®šã«é©å¿œå¯èƒ½ã€‚ãƒ“ãƒªãƒ“ãƒªã‚³ãƒ¡ãƒ³ãƒˆã€DingTalkãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã€Zhihuã€ãƒ•ã‚©ãƒ¼ãƒ©ãƒ ãªã©ã€ã»ã¼ã™ã¹ã¦ã®ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆã«å¯¾å¿œï¼
// @description:ru     NiceFont: ĞœĞ¾Ñ‰Ğ½Ñ‹Ğ¹ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚ Ğ´Ğ»Ñ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ Ğ²ĞµĞ±-ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ¾Ğ², Ğ¾Ğ±ĞµÑĞ¿ĞµÑ‡Ğ¸Ğ²Ğ°ÑÑ‰Ğ¸Ğ¹ Ğ±Ğ¾Ğ»ĞµĞµ Ñ‡ĞµÑ‚ĞºĞ¾Ğµ Ğ¸ ĞºĞ¾Ğ¼Ñ„Ğ¾Ñ€Ñ‚Ğ½Ğ¾Ğµ Ñ‡Ñ‚ĞµĞ½Ğ¸Ğµ! "ĞŸĞ¾-Ğ½Ğ°ÑÑ‚Ğ¾ÑÑ‰ĞµĞ¼Ñƒ Ñ€ĞµĞ³ÑƒĞ»Ğ¸Ñ€ÑƒĞµÑ‚ ÑˆÑ€Ğ¸Ñ„Ñ‚Ñ‹, Ğ° Ğ½Ğµ Ğ¼Ğ°ÑÑˆÑ‚Ğ°Ğ±Ğ¸Ñ€ÑƒĞµÑ‚ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ñƒ â€” Ğ½Ğ¸ĞºĞ°ĞºĞ¸Ñ… ĞºĞ¾Ğ¼Ğ¿Ñ€Ğ¾Ğ¼Ğ¸ÑÑĞ¾Ğ²!" ĞŸĞ¾Ğ·Ğ²Ğ¾Ğ»ÑĞµÑ‚ Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ÑƒÑ Ğ¸Ğ·Ğ¼ĞµĞ½ÑÑ‚ÑŒ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ¸ ÑÑ‚Ğ¸Ğ»ÑŒ ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ°, ÑĞ¾Ñ…Ñ€Ğ°Ğ½ÑÑ‚ÑŒ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Ğ¸ Ğ»ĞµĞ³ĞºĞ¾ Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ÑÑ‚ÑŒ Ğ¸Ñ… Ğº ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¹ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ğµ. ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµÑ‚ Ñ€Ğ°Ğ·Ğ¾Ğ²ÑƒÑ, Ğ·Ğ°Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½ÑƒÑ Ğ¸Ğ»Ğ¸ Ğ´Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºÑƒÑ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºÑƒ ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ¾Ğ², Ğ°Ğ´Ğ°Ğ¿Ñ‚Ğ¸Ñ€ÑƒĞµÑ‚ÑÑ Ğº Ğ¿Ğ¾Ğ´Ğ´Ğ¾Ğ¼ĞµĞ½Ğ°Ğ¼, Ñ†ĞµĞ»Ñ‹Ğ¼ ÑĞ°Ğ¹Ñ‚Ğ°Ğ¼ Ğ¸Ğ»Ğ¸ Ğ³Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¼ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ°Ğ¼. Ğ¡Ğ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼ Ñ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¸Ğ½ÑÑ‚Ğ²Ğ¾Ğ¼ ÑĞ°Ğ¹Ñ‚Ğ¾Ğ², Ğ²ĞºĞ»ÑÑ‡Ğ°Ñ ĞºĞ¾Ğ¼Ğ¼ĞµĞ½Ñ‚Ğ°Ñ€Ğ¸Ğ¸ Ğ½Ğ° Bilibili, Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ñ‹ DingTalk, Zhihu, Ñ„Ğ¾Ñ€ÑƒĞ¼Ñ‹ Ğ¸ Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ!
// @description:fr     NiceFont : Un outil puissant pour optimiser l'affichage des polices web, rendant la navigation plus claire et confortable ! Â« Ajuste rÃ©ellement les polices, pas un simple zoom de page â€” refusez les compromis ! Â» Modifie directement la taille et le style des polices, enregistre vos paramÃ¨tres et les applique facilement Ã  chaque page. Prend en charge les ajustements uniques, programmÃ©s ou dynamiques des polices, adaptable aux sous-domaines, sites entiers ou paramÃ¨tres globaux. Compatible avec presque tous les sites, y compris les commentaires de Bilibili, les documents DingTalk, Zhihu, les forums, et plus encore !
// @description:de     NiceFont: Ein leistungsstarkes Tool zur Optimierung der Webschriftanzeige fÃ¼r klareres und angenehmeres Surfen! "Passt Schriften wirklich an, statt die Seite zu skalieren â€” keine Kompromisse!" Ã„ndert SchriftgrÃ¶ÃŸe und -stil direkt, speichert Ihre Einstellungen und wendet sie mÃ¼helos auf jede Seite an. UnterstÃ¼tzt einmalige, geplante oder dynamische Schrifteinstellungen, anpassbar an Subdomains, ganze Websites oder globale Einstellungen. Kompatibel mit fast allen Websites, einschlieÃŸlich Bilibili-Kommentaren, DingTalk-Dokumenten, Zhihu, Foren und mehr!
// @description:es     NiceFont: Â¡Una poderosa herramienta para optimizar la visualizaciÃ³n de fuentes web, haciendo que la navegaciÃ³n sea mÃ¡s clara y cÃ³moda! "Ajusta realmente las fuentes, no solo escala la pÃ¡gina â€” Â¡sin concesiones!" Modifica directamente el tamaÃ±o y estilo de la fuente, guarda tus configuraciones y las aplica fÃ¡cilmente a cada pÃ¡gina. Admite ajustes Ãºnicos, programados o dinÃ¡micos de fuentes, adaptable a subdominios, sitios completos o configuraciones globales. Compatible con casi todos los sitios web, incluidos comentarios de Bilibili, documentos de DingTalk, Zhihu, foros y mÃ¡s!
// @description:pt     NiceFont: Uma ferramenta poderosa para otimizar a exibiÃ§Ã£o de fontes na web, tornando a navegaÃ§Ã£o mais clara e confortÃ¡vel! "Ajusta realmente as fontes, nÃ£o apenas escala a pÃ¡gina â€” sem concessÃµes!" Modifica diretamente o tamanho e estilo da fonte, salva suas configuraÃ§Ãµes e as aplica facilmente a cada pÃ¡gina. Suporta ajustes Ãºnicos, agendados ou dinÃ¢micos de fontes, adaptÃ¡vel a subdomÃ­nios, sites inteiros ou configuraÃ§Ãµes globais. CompatÃ­vel com quase todos os sites, incluindo comentÃ¡rios do Bilibili, documentos do DingTalk, Zhihu, fÃ³runs e mais!
// @homepageURL   https://github.com/10D24D/NiceFont/
// @namespace    https://github.com/10D24D/NiceFont/
// @icon         https://raw.githubusercontent.com/10D24D/NiceFont/main/static/logo.png
// @downloadURL  https://update.greasyfork.org/scripts/533232/NiceFont.user.js
// @updateURL    https://update.greasyfork.org/scripts/533232/NiceFont.meta.js
// @match        *://*/*
// @license      Apache License 2.0
// @grant        GM_registerMenuCommand
// @grant        GM_unregisterMenuCommand
// @grant        GM_getValue
// @grant        GM_setValue
// @grant        GM_addStyle
// @grant        GM_info
// @run-at       document-start
// @compatible   edge versionâ‰¥90 (Compatible Tampermonkey, Violentmonkey)
// @compatible   Chrome versionâ‰¥90 (Compatible Tampermonkey, Violentmonkey)
// @compatible   Firefox versionâ‰¥84 (Compatible Greasemonkey, Tampermonkey, Violentmonkey)
// @compatible   Opera versionâ‰¥78 (Compatible Tampermonkey, Violentmonkey)
// @compatible   Safari versionâ‰¥15.4 (Compatible Tampermonkey, Userscripts)
// @create       2025-4-18
// @copyright    2025, DD1024z
// ==/UserScript==

(function () {
    'use strict';

    // è°ƒè¯•å¼€å…³ï¼Œç”Ÿäº§ç¯å¢ƒä¸­ç¦ç”¨æ—¥å¿—
    const enableLogging = true;

    // å…³é—­è·Ÿè¸ªå¸¸é‡
    const CLOSE_TRACKING_WINDOW = 1800 * 1000; // 30 åˆ†é’Ÿï¼ˆæ¯«ç§’ï¼‰
    const CLOSE_COUNT_THRESHOLD = 2; // è¿ç»­å…³é—­ä¸¤æ¬¡

    /**
     * è‡ªå®šä¹‰æ—¥å¿—å‡½æ•°ï¼Œä»…åœ¨è°ƒè¯•æ¨¡å¼ä¸‹è¾“å‡º
     * @param {...any} args - æ—¥å¿—å‚æ•°
     */
    function log(...args) {
        if (enableLogging) {
            console.log('[NiceFont]', ...args);
        }
    }

    // è·³è¿‡ iframe æ‰§è¡Œ
    if (window.top !== window.self) {
        log('è·³è¿‡ iframe æ‰§è¡Œ');
        return;
    }

    // --- å·¥å…·å‡½æ•°æ¨¡å— ---
    const Utils = {
        /**
         * èŠ‚æµå‡½æ•°ï¼Œé™åˆ¶å‡½æ•°è°ƒç”¨é¢‘ç‡
         * @param {Function} fn - è¦èŠ‚æµçš„å‡½æ•°
         * @param {number} wait - èŠ‚æµé—´éš”ï¼ˆæ¯«ç§’ï¼‰
         * @returns {Function} èŠ‚æµåçš„å‡½æ•°
         */
        throttle(fn, wait) {
            let lastCall = 0;
            return function (...args) {
                const now = Date.now();
                if (now - lastCall >= wait) {
                    lastCall = now;
                    fn(...args);
                }
            };
        },

        /**
         * å°†å­—ä½“å¤§å°å•ä½è½¬æ¢ä¸ºåƒç´ 
         * @param {HTMLElement} el - å…ƒç´ 
         * @param {string} fontSize - å­—ä½“å¤§å°ï¼ˆå¸¦å•ä½ï¼‰
         * @returns {number} åƒç´ å€¼
         */
        convertToPx(el, fontSize) {
            if (!fontSize) return 16;
            if (fontSize.includes('rem')) {
                const rootFontSize = parseFloat(window.getComputedStyle(document.documentElement).fontSize);
                return parseFloat(fontSize) * rootFontSize;
            }
            if (fontSize.includes('em')) {
                const parentFontSize = parseFloat(window.getComputedStyle(el.parentElement).fontSize);
                return parseFloat(fontSize) * parentFontSize;
            }
            if (fontSize.includes('%')) {
                const parentFontSize = parseFloat(window.getComputedStyle(el.parentElement).fontSize);
                return (parseFloat(fontSize) / 100) * parentFontSize;
            }
            if (fontSize.includes('pt')) {
                return parseFloat(fontSize) * 1.3333;
            }
            if (fontSize.includes('vw')) {
                return parseFloat(fontSize) * window.innerWidth / 100;
            }
            if (fontSize.includes('vh')) {
                return parseFloat(fontSize) * window.innerHeight / 100;
            }
            return parseFloat(fontSize);
        },

        /**
         * æ£€æŸ¥å…ƒç´ æ˜¯å¦åŒ…å«å¯è§æ–‡æœ¬
         * @param {HTMLElement} el - å…ƒç´ 
         * @returns {boolean} æ˜¯å¦åŒ…å«å¯è§æ–‡æœ¬
         */
        hasVisibleText(el) {
            return Array.from(el.childNodes).some(
                node => node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== ''
            );
        },

        /**
         * è·å–é¡¶çº§åŸŸå
         * @returns {string} é¡¶çº§åŸŸåï¼ˆå¦‚ .example.comï¼‰
         */
        getTopLevelDomain() {
            const hostname = window.location.hostname;
            const parts = hostname.split('.');
            return parts.length >= 2 ? `.${parts.slice(-2).join('.')}` : hostname;
        }
    };

    // --- çŠ¶æ€ç®¡ç† ---
    const State = {
        fontIncrement: 1,
        currentFontFamily: 'none',
        currentAdjustment: 0,
        watchDOMChanges: false,
        intervalSeconds: 0,
        firstAdjustment: false,
        firstAdjustmentTime: 3,
        currentLanguage: 'en',
        panelType: 'floating',
        isConfigModified: false,
        targetScope: 1,
        pendingScopeChange: null,
        observer: null,
        timer: null,

        /**
         * è·å–çŠ¶æ€å€¼
         * @param {string} key - çŠ¶æ€é”®
         * @returns {any} çŠ¶æ€å€¼
         */
        get(key) {
            return this[key];
        },

        /**
         * è®¾ç½®çŠ¶æ€å€¼
         * @param {string} key - çŠ¶æ€é”®
         * @param {any} value - çŠ¶æ€å€¼
         */
        set(key, value) {
            this[key] = value;
        }
    };

    // --- é…ç½®èŒƒå›´ç®¡ç† ---
    const ConfigScopeManager = {
        BASE_STORAGE_KEY: 'NiceFont_config',
        GLOBAL_DEFAULT_KEY: 'NiceFont_global_default_config',
        PANEL_TYPE_KEY: 'NiceFont_panelType',
        scopeMap: { 1: 'subdomain', 2: 'topLevelDomain', 3: 'allWebsites' },

        /**
         * åˆå§‹åŒ–åŠ¨æ€é”®
         */
        initKeys() {
            this.subdomainKey = `${this.BASE_STORAGE_KEY}_${window.location.hostname}`;
            this.topLevelKey = `${this.BASE_STORAGE_KEY}_${Utils.getTopLevelDomain()}`;
        },

        /**
         * è·å–å½“å‰é…ç½®é”®
         * @returns {string} é…ç½®é”®
         */
        getConfigKey() {
            this.initKeys();
            const scope = State.get('targetScope');
            if (scope === 1) return this.subdomainKey;
            if (scope === 2) return this.topLevelKey;
            return this.GLOBAL_DEFAULT_KEY;
        },

        /**
         * è·å–å½“å‰ç”Ÿæ•ˆçš„é…ç½®èŒƒå›´
         * @returns {number} èŒƒå›´ï¼ˆ1: å­åŸŸå, 2: é¡¶çº§åŸŸå, 3: æ‰€æœ‰ç½‘ç«™ï¼‰
         */
        getEffectiveScope() {
            this.initKeys();
            const subdomainConfig = GM_getValue(this.subdomainKey, {});
            const topLevelConfig = GM_getValue(this.topLevelKey, {});
            const globalConfig = GM_getValue(this.GLOBAL_DEFAULT_KEY, {});
            if (Object.keys(subdomainConfig).length > 0) return 1;
            if (Object.keys(topLevelConfig).length > 0) return 2;
            if (Object.keys(globalConfig).length > 0) return 3;
            return 1; // é»˜è®¤è¿”å›å­åŸŸå
        },

        /**
         * æ£€æŸ¥å½“å‰ç½‘ç«™æ˜¯å¦å·²æœ‰é…ç½®
         * @returns {boolean} æ˜¯å¦å­˜åœ¨é…ç½®
         */
        hasConfig() {
            this.initKeys();
            const configKey = this.getConfigKey();
            const config = GM_getValue(configKey, null);
            const hasConfig = !!config && Object.keys(config).length > 0;
            log(`æ£€æŸ¥é…ç½®: key=${configKey}, hasConfig=${hasConfig}, config=${JSON.stringify(config)}`);
            return hasConfig;
        },

        /**
         * è·å–èŒƒå›´æ˜¾ç¤ºæ–‡æœ¬
         * @param {number} scope - èŒƒå›´
         * @param {Object} t - ç¿»è¯‘å¯¹è±¡
         * @returns {string} æ˜¾ç¤ºæ–‡æœ¬
         */
        getScopeText(scope, t) {
            return scope === 1 ? t.subdomain : scope === 2 ? t.topLevelDomain : t.allWebsites;
        },

        /**
         * è·å–å½“å‰é…ç½®æ¥æºæ–‡æœ¬
         * @param {Object} t - ç¿»è¯‘å¯¹è±¡
         * @returns {string} é…ç½®æ¥æºæ–‡æœ¬
         */
        getCurrentConfigText(t) {
            this.initKeys();
            const subdomainConfig = GM_getValue(this.subdomainKey, {});
            const topLevelConfig = GM_getValue(this.topLevelKey, {});
            const globalConfig = GM_getValue(this.GLOBAL_DEFAULT_KEY, {});
            if (Object.keys(subdomainConfig).length > 0) return window.location.hostname;
            if (Object.keys(topLevelConfig).length > 0) return `*.${Utils.getTopLevelDomain().replace(/^\./, '')}`;
            if (Object.keys(globalConfig).length > 0) return t.allWebsites;
            return t.notConfigured;
        },

        /**
         * è·å–é…ç½®èŒƒå›´æ˜¾ç¤ºæ–‡æœ¬ï¼ˆåŒ…å«ç›®æ ‡èŒƒå›´ï¼‰
         * @param {Object} t - ç¿»è¯‘å¯¹è±¡
         * @returns {string} æ˜¾ç¤ºæ–‡æœ¬
         */
        getConfigScopeDisplayText(t) {
            const effectiveScope = this.getEffectiveScope();
            const currentScopeText = this.getScopeText(effectiveScope, t);
            const pendingScope = State.get('pendingScopeChange');
            if (pendingScope && pendingScope !== effectiveScope) {
                const targetScopeText = this.getScopeText(pendingScope, t);
                return `${currentScopeText} -> ${targetScopeText}`;
            }
            return currentScopeText;
        },

        /**
         * åˆ é™¤æŒ‡å®šèŒƒå›´çš„é…ç½®
         * @param {number} scope - èŒƒå›´
         * @returns {boolean} æ˜¯å¦åˆ é™¤æˆåŠŸ
         */
        deleteConfig(scope) {
            this.initKeys();
            const t = translations[State.get('currentLanguage')] || translations.en;
            let key, target;
            if (scope === 1) {
                key = this.subdomainKey;
                target = window.location.hostname;
            } else if (scope === 2) {
                key = this.topLevelKey;
                target = `*.${Utils.getTopLevelDomain().replace(/^\./, '')}`;
            } else {
                key = this.GLOBAL_DEFAULT_KEY;
                target = t.allWebsites;
            }
            GM_setValue(key, {});
            log(`åˆ é™¤é…ç½®: ${target}`);
            return true;
        }
    };

    // --- é…ç½®ç®¡ç† ---
    const ConfigManager = {
        /**
         * åŠ è½½é…ç½®
         */
        loadConfig() {
            ConfigScopeManager.initKeys();
            let config = GM_getValue(ConfigScopeManager.subdomainKey, {});
            let effectiveScope = 1;
            if (Object.keys(config).length === 0) {
                config = GM_getValue(ConfigScopeManager.topLevelKey, {});
                effectiveScope = 2;
                if (Object.keys(config).length === 0) {
                    config = GM_getValue(ConfigScopeManager.GLOBAL_DEFAULT_KEY, {});
                    effectiveScope = Object.keys(config).length > 0 ? 3 : 1; // ç©ºå…¨å±€é…ç½®æ—¶é»˜è®¤å­åŸŸå
                }
            }
            State.set('fontIncrement', config.increment || 1);
            State.set('currentFontFamily', config.fontFamily || 'none');
            State.set('currentAdjustment', config.resize || 0);
            State.set('watchDOMChanges', config.watcher || false);
            State.set('intervalSeconds', config.timer || 0);
            State.set('firstAdjustment', config.first || false);
            State.set('firstAdjustmentTime', config.firstTime || 3);
            State.set('targetScope', effectiveScope);
            log('åŠ è½½é…ç½®:', config, 'ç”Ÿæ•ˆèŒƒå›´:', effectiveScope);
        },

        /**
         * ä¿å­˜é…ç½®
         */
        saveConfig() {
            const t = translations[State.get('currentLanguage')] || translations.en;
            // ä½¿ç”¨ pendingScopeChangeï¼ˆè‹¥å­˜åœ¨ï¼‰ï¼Œå¦åˆ™ä½¿ç”¨ targetScope
            let scope = State.get('pendingScopeChange') !== null ? State.get('pendingScopeChange') : State.get('targetScope');
            // å¦‚æœé…ç½®å·²ä¿®æ”¹ä¸”æ—  pendingScopeChangeï¼Œä¼˜å…ˆä½¿ç”¨ UI æ˜¾ç¤ºçš„ scope
            if (State.get('isConfigModified') && State.get('pendingScopeChange') === null) {
                scope = ConfigScopeManager.getEffectiveScope();
                if (scope === 3 && Object.keys(GM_getValue(ConfigScopeManager.GLOBAL_DEFAULT_KEY, {})).length === 0) {
                    scope = 1; // æ— å…¨å±€é…ç½®æ—¶ï¼Œé»˜è®¤å­åŸŸå
                }
            }
            const scopeText = ConfigScopeManager.getScopeText(scope, t);
            const target = scope === 1 ? window.location.hostname :
                scope === 2 ? `*.${Utils.getTopLevelDomain().replace(/^\./, '')}` : t.allWebsites;
            const confirmMessage = scope === 3 ?
                t.saveConfigConfirm.replace('{scope}', scopeText).replace(' [{target}]', '') :
                t.saveConfigConfirm.replace('{scope}', scopeText).replace('{target}', target);

            if (confirm(confirmMessage)) {
                const config = {
                    increment: State.get('fontIncrement'),
                    resize: State.get('currentAdjustment'),
                    watcher: State.get('watchDOMChanges'),
                    timer: State.get('intervalSeconds'),
                    fontFamily: State.get('currentFontFamily'),
                    first: State.get('firstAdjustment'),
                    firstTime: State.get('firstAdjustmentTime')
                };
                ConfigScopeManager.initKeys();
                const key = scope === 1 ? ConfigScopeManager.subdomainKey :
                    scope === 2 ? ConfigScopeManager.topLevelKey : ConfigScopeManager.GLOBAL_DEFAULT_KEY;
                GM_setValue(key, config);
                State.set('isConfigModified', false);
                State.set('targetScope', scope);
                State.set('pendingScopeChange', null);
                ConfigManager.loadConfig(); // åˆ·æ–°é…ç½®
                UIManager.updateUI();
                log(`ä¿å­˜é…ç½®åˆ°: ${target} (scope=${scope})`);
            }
        },

        /**
         * æ›´æ”¹é…ç½®èŒƒå›´
         */
        changeConfigScope() {
            const t = translations[State.get('currentLanguage')] || translations.en;
            const effectiveScope = ConfigScopeManager.getEffectiveScope();
            const currentScopeText = ConfigScopeManager.getScopeText(effectiveScope, t);
            const input = prompt(
                t.configScopePrompt
                    .replace('{scope}', currentScopeText)
                    .replace('{hostname}', window.location.hostname)
                    .replace('{tld}', Utils.getTopLevelDomain().replace(/^\./, '')),
                State.get('targetScope')
            );
            const newScope = parseInt(input, 10);
            if (![1, 2, 3].includes(newScope)) {
                if (input !== null) alert(t.invalidInput);
                return;
            }
            if (newScope === effectiveScope) {
                log(`æ–°èŒƒå›´ä¸å½“å‰èŒƒå›´ç›¸åŒ: ${ConfigScopeManager.scopeMap[newScope]}`);
                return;
            }
            ConfigScopeManager.initKeys();
            const hasConfig = effectiveScope === 1 ? Object.keys(GM_getValue(ConfigScopeManager.subdomainKey, {})).length > 0 :
                effectiveScope === 2 ? Object.keys(GM_getValue(ConfigScopeManager.topLevelKey, {})).length > 0 :
                    Object.keys(GM_getValue(ConfigScopeManager.GLOBAL_DEFAULT_KEY, {})).length > 0;

            if (newScope > effectiveScope && hasConfig) {
                const confirmMessage = effectiveScope === 3 ?
                    `${t.currentConfigScope}: ${ConfigScopeManager.getCurrentConfigText(t)}\n${t.deleteBeforeScopeChangeConfirm.replace('{scope}', ConfigScopeManager.getScopeText(effectiveScope, t)).replace(' [{target}]', '')}` :
                    `${t.currentConfigScope}: ${ConfigScopeManager.getCurrentConfigText(t)}\n${t.deleteBeforeScopeChangeConfirm.replace('{scope}', ConfigScopeManager.getScopeText(effectiveScope, t)).replace('{target}', ConfigScopeManager.getCurrentConfigText(t))}`;
                if (confirm(confirmMessage)) {
                    ConfigScopeManager.deleteConfig(effectiveScope);
                    State.set('pendingScopeChange', newScope);
                    State.set('targetScope', newScope);
                    State.set('isConfigModified', true);
                    UIManager.updateUI();
                    log(`æ ‡è®°èŒƒå›´æ›´æ”¹ä¸º: ${ConfigScopeManager.scopeMap[newScope]}`);
                }
            } else {
                State.set('pendingScopeChange', newScope);
                State.set('targetScope', newScope);
                State.set('isConfigModified', true);
                UIManager.updateUI();
                log(`æ ‡è®°èŒƒå›´æ›´æ”¹ä¸º: ${ConfigScopeManager.scopeMap[newScope]}`);
            }
        },

        /**
         * åˆ é™¤å½“å‰é…ç½®
         */
        deleteCurrentConfig() {
            const effectiveScope = ConfigScopeManager.getEffectiveScope();
            const t = translations[State.get('currentLanguage')] || translations.en;
            const scopeText = ConfigScopeManager.getScopeText(effectiveScope, t);
            const target = ConfigScopeManager.getCurrentConfigText(t);

            if (target === t.notConfigured) {
                log('æ— é…ç½®å¯åˆ é™¤');
                return false;
            }

            const confirmMessage = effectiveScope === 3 ?
                `${t.currentConfigScope}: ${target}\n${t.deleteConfigConfirm.replace('{scope}', scopeText).replace(' [{target}]', '')}` :
                `${t.currentConfigScope}: ${target}\n${t.deleteConfigConfirm.replace('{scope}', scopeText).replace('{target}', target)}`;

            if (confirm(confirmMessage)) {
                ConfigScopeManager.deleteConfig(effectiveScope);
                State.set('targetScope', 1); // å¼ºåˆ¶è®¾ä¸ºå­åŸŸå
                State.set('pendingScopeChange', null); // æ¸…ç©ºå¾…å®šèŒƒå›´
                ConfigManager.loadConfig();
                UIManager.updateUI();
                log('é…ç½®å·²åˆ é™¤ï¼ŒtargetScope é‡ç½®ä¸º 1');
                return true;
            }
            return false;
        }
    };

    // --- å­—ä½“ç®¡ç† ---
    const FontManager = {
        supportFonts: [
            'custom', 'auto', 'Arial', 'cursive', 'fangsong', 'fantasy', 'monospace', 'none',
            'sans-serif', 'serif', 'system-ui', 'ui-monospace', 'ui-rounded', 'ui-sans-serif',
            'ui-serif', '-webkit-body', 'inherit', 'initial', 'unset', 'Verdana', 'Helvetica',
            'Tahoma', 'Times New Roman', 'Georgia', 'Courier New', 'Comic Sans MS'
        ],
        styleCache: new WeakMap(),

        /**
         * è·å–ç¼“å­˜çš„è®¡ç®—æ ·å¼
         * @param {HTMLElement} el - å…ƒç´ 
         * @returns {CSSStyleDeclaration} è®¡ç®—æ ·å¼
         */
        getCachedStyle(el) {
            if (!this.styleCache.has(el)) {
                this.styleCache.set(el, window.getComputedStyle(el));
            }
            return this.styleCache.get(el);
        },

        /**
         * é€’å½’éå† DOM å…ƒç´ 
         * @param {HTMLElement} el - æ ¹å…ƒç´ 
         * @param {Function} callback - å›è°ƒå‡½æ•°
         */
        traverseDOM(el, callback) {
            if (el.nodeType !== Node.ELEMENT_NODE || el.id === 'NiceFont_panel' || el.hasAttribute('data-nicefont-panel')) {
                return;
            }
            callback(el);
            if (el.tagName === 'IFRAME') {
                try {
                    const iframeDoc = el.contentDocument || el.contentWindow.document;
                    if (iframeDoc) {
                        this.traverseDOM(iframeDoc.body, callback);
                        const font = State.get('currentFontFamily');
                        if (font !== 'none') {
                            iframeDoc.documentElement.style.setProperty('--nicefont-family', font);
                        } else {
                            iframeDoc.documentElement.style.removeProperty('--nicefont-family');
                        }
                    }
                } catch (e) {
                    console.error('[NiceFont] è®¿é—® iframe å¤±è´¥:', e);
                }
            }
            if (el.shadowRoot) {
                try {
                    el.shadowRoot.querySelectorAll('*').forEach(child => this.traverseDOM(child, callback));
                } catch (e) {
                    console.error('[NiceFont] å¤„ç† Shadow DOM å¤±è´¥:', e);
                }
            }
            Array.from(el.children).forEach(child => requestAnimationFrame(() => this.traverseDOM(child, callback)));
        },

        /**
         * åº”ç”¨å­—ä½“è°ƒæ•´
         * @param {HTMLElement} el - æ ¹å…ƒç´ 
         * @param {number} increment - å­—ä½“å¤§å°å¢é‡ï¼ˆpxï¼‰
         */
        applyFontRecursively(el, increment) {
            this.traverseDOM(el, (node) => {
                const style = this.getCachedStyle(node);
                const isVisible = style.display !== 'none' && style.visibility !== 'hidden';
                if (Utils.hasVisibleText(node) && isVisible) {
                    let currentFontSize = node.style.fontSize || style.fontSize;
                    if (!node.hasAttribute('data-default-fontsize')) {
                        node.setAttribute('data-default-fontsize', currentFontSize);
                    }
                    const baseFontSize = parseFloat(Utils.convertToPx(node, node.getAttribute('data-default-fontsize')));
                    if (!isNaN(baseFontSize)) {
                        node.style.fontSize = `${baseFontSize + increment}px`;
                    }
                }
            });
            const font = State.get('currentFontFamily');
            if (font !== 'none') {
                document.documentElement.style.setProperty('--nicefont-family', font);
            } else {
                document.documentElement.style.removeProperty('--nicefont-family');
            }
        },

        /**
         * é‡ç½®å­—ä½“
         * @param {HTMLElement} el - æ ¹å…ƒç´ 
         */
        resetFont(el) {
            this.traverseDOM(el, (node) => {
                const defaultSize = node.getAttribute('data-default-fontsize');
                if (defaultSize) {
                    node.style.fontSize = defaultSize;
                    node.removeAttribute('data-default-fontsize');
                } else {
                    node.style.removeProperty('font-size');
                }
                node.style.removeProperty('font-family');
            });
            try {
                document.documentElement.style.removeProperty('--nicefont-family');
            } catch (e) {
                console.error('[NiceFont] ç§»é™¤ --nicefont-family å¤±è´¥:', e);
            }
            // é‡ç½®å…³é—­è·Ÿè¸ªçŠ¶æ€
            GM_setValue('NiceFont_closeCount', 0);
            GM_setValue('NiceFont_lastCloseTime', 0);
            GM_setValue('NiceFont_autoOpenDisabled', false);
            log('é‡ç½®å…³é—­è·Ÿè¸ªçŠ¶æ€');
        },

        /**
         * ä¿®æ”¹å­—ä½“å¤§å°
         * @param {number} increment - å¢é‡ï¼ˆpxï¼‰
         */
        changeFontSize(increment) {
            State.set('currentAdjustment', State.get('currentAdjustment') + increment);
            this.applyFontRecursively(document.body, State.get('currentAdjustment'));
            State.set('isConfigModified', true);
            UIManager.updateUI();
            log(`å­—ä½“å¤§å°è°ƒæ•´: ${increment}px, å½“å‰: ${State.get('currentAdjustment')}px`);
        }
    };

    // --- ç•Œé¢ç®¡ç† ---
    const UIManager = {
        menuHandles: [],
        panelCache: null,
        overlayCache: null,
        lastToggleTime: 0, // ç”¨äºé˜²æŠ–

        /**
         * å®šä¹‰å‘½ä»¤é…ç½®
         * @returns {Array} å‘½ä»¤é…ç½®æ•°ç»„
         */
        getCommandsConfig() {
            const t = translations[State.get('currentLanguage')] || translations.en;
            return [
                {
                    id: 'setFontFamily',
                    getText: () => `ğŸ”  ${t.setFontFamily}: ${State.get('currentFontFamily')}`,
                    action: () => {
                        const t = translations[State.get('currentLanguage')] || translations.en;
                        let select = document.getElementById('NiceFont_font-family');
                        if (select) {
                            select.remove();
                            document.removeEventListener('click', this.closeDropdown);
                            return;
                        }
                        select = document.createElement('select');
                        select.id = 'NiceFont_font-family';
                        select.className = 'font-family-select';
                        select.innerHTML = FontManager.supportFonts.map(font =>
                            `<option value="${font}" ${font === State.get('currentFontFamily') ? 'selected' : ''}>${font === 'custom' ? (State.get('currentLanguage') === 'zh' ? 'æ‰‹åŠ¨è¾“å…¥' : 'Custom Input') : font}</option>`
                        ).join('');
                        const btn = document.getElementById('NiceFont_setFontFamily');
                        if (btn) btn.appendChild(select);
                        select.focus();
                        select.addEventListener('click', e => e.stopPropagation());
                        select.addEventListener('change', (e) => {
                            const selectedFont = e.target.value;
                            if (selectedFont === 'custom') {
                                const input = prompt(`${t.setFontFamilyPrompt}\n\n${t.supportFontFamily}\n${FontManager.supportFonts.slice(0, -1).join(', ')}`, '');
                                if (input && input.trim()) {
                                    const newFont = input.trim();
                                    if (!FontManager.supportFonts.includes(newFont)) {
                                        FontManager.supportFonts.splice(FontManager.supportFonts.length - 1, 0, newFont);
                                        const option = document.createElement('option');
                                        option.value = newFont;
                                        option.textContent = newFont;
                                        select.insertBefore(option, select.lastChild);
                                    }
                                    State.set('currentFontFamily', newFont);
                                    select.value = newFont;
                                } else {
                                    select.value = State.get('currentFontFamily');
                                    select.remove();
                                    document.removeEventListener('click', this.closeDropdown);
                                    log('å–æ¶ˆè‡ªå®šä¹‰å­—ä½“è¾“å…¥');
                                    return;
                                }
                            } else {
                                State.set('currentFontFamily', selectedFont);
                            }
                            FontManager.applyFontRecursively(document.body, State.get('currentAdjustment'));
                            State.set('isConfigModified', true);
                            UIManager.updateUI();
                            select.remove();
                            document.removeEventListener('click', this.closeDropdown);
                            log(`å­—ä½“ç±»å‹è®¾ç½®ä¸º: ${State.get('currentFontFamily')}`);
                        });
                        this.closeDropdown = (event) => {
                            if (!select.contains(event.target) && !btn.contains(event.target)) {
                                select.remove();
                                document.removeEventListener('click', this.closeDropdown);
                                log('ä¸‹æ‹‰èœå•å…³é—­');
                            }
                        };
                        document.addEventListener('click', this.closeDropdown);
                    }
                },
                {
                    id: 'status',
                    getText: () => `ğŸ“ ${t.fontSizeAdjustment}: ${State.get('currentAdjustment') >= 0 ? '+' : ''}${State.get('currentAdjustment')}px`,
                    action: () => { }
                },
                {
                    id: 'increase',
                    getText: () => `ğŸ”¼ ${t.increase}`,
                    action: () => FontManager.changeFontSize(State.get('fontIncrement')),
                    autoClose: false
                },
                {
                    id: 'decrease',
                    getText: () => `ğŸ”½ ${t.decrease}`,
                    action: () => FontManager.changeFontSize(-State.get('fontIncrement')),
                    autoClose: false
                },
                {
                    id: 'reset',
                    getText: () => `ğŸ”„ï¸ ${t.reset}`,
                    action: () => {
                        FontManager.resetFont(document.body);
                        State.set('currentAdjustment', 0);
                        State.set('currentFontFamily', 'none');
                        State.set('watchDOMChanges', false);
                        State.set('intervalSeconds', 0);
                        State.set('firstAdjustment', false);
                        State.set('firstAdjustmentTime', 3);
                        if (State.get('observer')) {
                            State.get('observer').disconnect();
                            State.set('observer', null);
                        }
                        if (State.get('timer')) {
                            clearInterval(State.get('timer'));
                            State.set('timer', null);
                        }
                        State.set('isConfigModified', true);
                        UIManager.updateUI();
                        log('å­—ä½“è®¾ç½®é‡ç½®');
                    }
                },
                {
                    id: 'first-adjustment',
                    getText: () => `1ï¸âƒ£ ${State.get('firstAdjustment') ? t.firstAdjustmentEnabled : t.firstAdjustmentDisabled} ${State.get('firstAdjustment') ? `ã€${State.get('firstAdjustmentTime')}sã€‘` : ''}`,
                    action: () => {
                        const input = prompt(t.firstAdjustmentConfirm, State.get('firstAdjustmentTime').toString());
                        const secs = parseInt(input, 10);
                        if (!isNaN(secs)) {
                            State.set('firstAdjustment', !State.get('firstAdjustment'));
                            State.set('firstAdjustmentTime', secs);
                            if (secs === 0) State.set('firstAdjustment', false);
                            if (State.get('firstAdjustment')) {
                                setTimeout(() => {
                                    FontManager.applyFontRecursively(document.body, State.get('currentAdjustment'));
                                    log('åº”ç”¨é¦–æ¬¡å­—ä½“è°ƒæ•´');
                                }, State.get('firstAdjustmentTime') * 1000);
                            }
                            State.set('isConfigModified', true);
                            if (this.panelCache) {
                                this.updatePanelContent();
                            }
                            log(`é¦–æ¬¡è°ƒæ•´è®¾ç½®ä¸º: ${secs}s`);
                        }
                    }
                },
                {
                    id: 'timer-adjustment',
                    getText: () => `â±ï¸ ${State.get('intervalSeconds') > 0 ? t.timerAdjustmentEnabled : t.timerAdjustmentDisabled} ${State.get('intervalSeconds') > 0 ? `ã€${State.get('intervalSeconds')}sã€‘` : ''}`,
                    action: () => {
                        const input = prompt(t.timerPrompt, State.get('intervalSeconds').toString());
                        const secs = parseInt(input, 10);
                        if (!isNaN(secs)) {
                            State.set('intervalSeconds', secs);
                            if (secs > 0) {
                                State.set('watchDOMChanges', false);
                                if (State.get('observer')) State.get('observer').disconnect();
                                if (State.get('timer')) clearInterval(State.get('timer'));
                                State.set('timer', setInterval(() => {
                                    FontManager.applyFontRecursively(document.body, State.get('currentAdjustment'));
                                }, secs * 1000));
                                log(`å®šæ—¶è°ƒæ•´è®¾ç½®ä¸º: ${secs}s`);
                            } else {
                                if (State.get('timer')) clearInterval(State.get('timer'));
                                log('å®šæ—¶è°ƒæ•´ç¦ç”¨');
                            }
                            State.set('isConfigModified', true);
                            if (this.panelCache) {
                                this.updatePanelContent();
                            }
                            log(`å®šæ—¶è°ƒæ•´è®¾ç½®ä¸º: ${secs}s`);
                        }
                    }
                },
                {
                    id: 'dynamic-adjustment',
                    getText: () => `ğŸ” ${State.get('watchDOMChanges') ? t.dynamicAdjustmentEnabled : t.dynamicAdjustmentDisabled}`,
                    action: () => {
                        if (confirm(t.dynamicWatchConfirm)) {
                            State.set('watchDOMChanges', !State.get('watchDOMChanges'));
                            if (State.get('watchDOMChanges')) {
                                State.set('intervalSeconds', 0);
                                if (State.get('timer')) clearInterval(State.get('timer'));
                                const nodeCount = document.body.getElementsByTagName('*').length;
                                const throttleTime = nodeCount > 10000 ? 200 : 100;
                                State.set('observer', new MutationObserver(Utils.throttle(() => {
                                    FontManager.applyFontRecursively(document.body, State.get('currentAdjustment'));
                                }, throttleTime)));
                                State.get('observer').observe(document.body, { childList: true, subtree: true });
                                log('åŠ¨æ€è°ƒæ•´å¯ç”¨');
                            } else {
                                if (State.get('observer')) State.get('observer').disconnect();
                                log('åŠ¨æ€è°ƒæ•´ç¦ç”¨');
                            }
                            State.set('isConfigModified', true);
                            if (this.panelCache) {
                                this.updatePanelContent();
                            }
                        }
                    }
                },
                {
                    id: 'switch-language',
                    getText: () => `ğŸŒ ${t.usageLanguage}: ${State.get('currentLanguage')}`,
                    action: () => {
                        let input;
                        do {
                            input = prompt('zh: æ±‰è¯­ \t en: English \t ko: í•œêµ­ì–´ \t ja: æ—¥æœ¬èª \t ru: Ğ ÑƒÑÑĞºĞ¸Ğ¹ \t fr: FranÃ§ais \t de: Deutsch \t es: EspaÃ±ol \t pt: PortuguÃªs', State.get('currentLanguage'));
                            if (input && !Object.keys(translations).includes(input.trim())) {
                                alert('Invalid language code!');
                            }
                        } while (input && !Object.keys(translations).includes(input.trim()));
                        if (input && input.trim()) {
                            State.set('currentLanguage', input.trim());
                            GM_setValue('language', State.get('currentLanguage'));
                            UIManager.updateUI();
                            if (this.panelCache) {
                                this.panelCache.remove();
                                this.overlayCache.remove();
                                this.createFloatingPanel();
                            }
                            log(`è¯­è¨€åˆ‡æ¢ä¸º: ${State.get('currentLanguage')}`);
                        }
                    }
                },
                {
                    id: 'switch-panel',
                    getText: () => `ğŸ¨ ${t.switchPanel}: ${State.get('panelType') === 'tampermonkey' ? t.tampermonkeyPanel : t.floatingPanel}`,
                    action: () => {
                        const newPanelType = State.get('panelType') === 'tampermonkey' ? 'floating' : 'tampermonkey';
                        GM_setValue(ConfigScopeManager.PANEL_TYPE_KEY, newPanelType);
                        State.set('panelType', newPanelType);
                        if (this.panelCache) {
                            this.panelCache.remove();
                            this.overlayCache.remove();
                            this.panelCache = null;
                            this.overlayCache = null;
                        }
                        UIManager.updateUI();
                        log(`åˆ‡æ¢åˆ°é¢æ¿ç±»å‹: ${newPanelType}`);
                    }
                },
                {
                    id: 'show-panel',
                    getText: () => `ğŸ“… ${t.showPanel}`,
                    action: () => this.togglePanel(),
                    tampermonkeyOnly: true
                },
                {
                    id: 'currentConfigScope',
                    getText: () => `ğŸ“ ${t.currentConfigScope}: ${ConfigScopeManager.getCurrentConfigText(t)}`,
                    action: ConfigManager.deleteCurrentConfig
                },
                {
                    id: 'config-scope',
                    getText: () => `â„¹ï¸ ${t.configScope}: ${ConfigScopeManager.getConfigScopeDisplayText(t)}`,
                    action: ConfigManager.changeConfigScope
                },
                {
                    id: 'save-config',
                    getText: () => `ğŸ’¾ ${State.get('isConfigModified') ? t.saveConfigPending : t.saveConfig}`,
                    action: ConfigManager.saveConfig
                }
            ];
        },

        /**
         * åˆ›å»ºæµ®åŠ¨é¢æ¿
         */
        createFloatingPanel() {
            if (this.panelCache) {
                log('panelCache å·²å­˜åœ¨ï¼Œè·³è¿‡åˆ›å»º');
                return;
            }
            const t = translations[State.get('currentLanguage')] || translations.en;
            const scriptName = GM_info?.script?.name || 'NiceFont';

            // åˆå§‹åŒ–é¢æ¿
            this.panelCache = document.createElement('div');
            this.panelCache.id = 'NiceFont_panel';
            this.panelCache.setAttribute('data-nicefont-panel', 'true');
            this.panelCache.style.position = 'fixed';
            this.panelCache.style.width = '300px';
            this.panelCache.style.background = '#fff';
            this.panelCache.style.border = '1px solid #ccc';
            this.panelCache.style.borderRadius = '5px';
            this.panelCache.style.padding = '10px';
            this.panelCache.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
            this.panelCache.style.zIndex = '10001';
            this.panelCache.style.fontFamily = 'sans-serif';
            this.panelCache.style.fontSize = '15px';
            this.panelCache.style.userSelect = 'none';

            // åˆå§‹åŒ–é®ç½©å±‚
            this.overlayCache = document.createElement('div');
            this.overlayCache.id = 'NiceFont_overlay';
            this.overlayCache.style.display = 'none';

            // åŠ è½½ä¿å­˜çš„é¢æ¿ä½ç½®
            const savedPosition = GM_getValue('NiceFont_panelPosition', { top: '50px', right: '20px' });
            this.panelCache.style.top = savedPosition.top;
            this.panelCache.style.right = savedPosition.right;
            this.panelCache.style.left = 'auto';

            // è®¾ç½®é¢æ¿å†…å®¹
            this.panelCache.innerHTML = `
                <div class="NiceFont_header" style="position: relative; z-index: 10002; display: flex; align-items: center; justify-content: space-between;">
                    <div style="font-size: 16px; text-align: left; flex-grow: 1; cursor: grab; margin: 5px; font-weight: bold;">${scriptName}</div>
                    <button class="NiceFont_close-btn" id="NiceFont_close-btn" style="border: none; border-radius: 3px; padding: 1px 6px; cursor: pointer; line-height: 16px; font-size: 12px; background: none; color: #000;">âœ–ï¸</button>
                </div>
                <div class="NiceFont_content"></div>
            `;

            // å¡«å……å†…å®¹åŒºåŸŸ
            this.updatePanelContent();

            // ç¡®ä¿ DOM å¯ç”¨å¹¶æ·»åŠ é¢æ¿
            try {
                if (document.body) {
                    document.body.appendChild(this.overlayCache);
                    document.body.appendChild(this.panelCache);
                    log('æµ®åŠ¨é¢æ¿åˆ›å»ºæˆåŠŸ');
                } else {
                    console.error('[NiceFont] document.body ä¸å¯ç”¨');
                    return;
                }
            } catch (e) {
                console.error('[NiceFont] åˆ›å»ºé¢æ¿å¤±è´¥:', e);
                return;
            }

            // è·å– header å…ƒç´ 
            const header = this.panelCache.querySelector('.NiceFont_header');
            if (!header) {
                console.error('[NiceFont] æœªæ‰¾åˆ° .NiceFont_headerï¼Œæ— æ³•ç»‘å®šæ‹–æ‹½äº‹ä»¶');
                return;
            }

            // æ·»åŠ æ‹–åŠ¨åŠŸèƒ½
            let isDragging = false;
            let initialX;
            let initialY;
            let rafId = null;

            header.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('NiceFont_close-btn')) {
                    log('ç‚¹å‡»å…³é—­æŒ‰é’®ï¼Œå¿½ç•¥æ‹–æ‹½');
                    return;
                }
                isDragging = true;
                initialX = e.clientX + parseFloat(this.panelCache.style.right || '0');
                initialY = e.clientY - parseFloat(this.panelCache.style.top || '0');
                header.style.cursor = 'grabbing';
                log('å¼€å§‹æ‹–æ‹½');
                e.preventDefault();
                e.stopPropagation();
            }, { capture: true, passive: false });

            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    e.preventDefault();
                    if (rafId) cancelAnimationFrame(rafId);
                    rafId = requestAnimationFrame(() => {
                        let newX = initialX - e.clientX;
                        let newY = e.clientY - initialY;
                        newX = Math.max(0, Math.min(newX, window.innerWidth - this.panelCache.offsetWidth));
                        newY = Math.max(0, Math.min(newY, window.innerHeight - this.panelCache.offsetHeight));
                        this.panelCache.style.right = `${newX}px`;
                        this.panelCache.style.top = `${newY}px`;
                        this.panelCache.style.left = 'auto';
                        log(`æ‹–æ‹½ä¸­: right=${newX}px, top=${newY}px`);
                    });
                }
            }, { capture: true, passive: false });

            document.addEventListener('mouseup', (e) => {
                if (isDragging) {
                    isDragging = false;
                    header.style.cursor = 'grab';
                    if (rafId) {
                        cancelAnimationFrame(rafId);
                        rafId = null;
                    }
                    GM_setValue('NiceFont_panelPosition', {
                        top: this.panelCache.style.top,
                        right: this.panelCache.style.right
                    });
                    log('æ‹–æ‹½ç»“æŸ, é¢æ¿ä½ç½®ä¿å­˜:', this.panelCache.style.top, this.panelCache.style.right);
                    e.stopPropagation();
                }
            }, { capture: true, passive: false });

            // æ·»åŠ é•¿æŒ‰åŠŸèƒ½
            let longPressTimer = null;
            const startLongPress = (action, interval = 100) => {
                action();
                longPressTimer = setInterval(action, interval);
            };
            const stopLongPress = () => {
                if (longPressTimer) {
                    clearInterval(longPressTimer);
                    longPressTimer = null;
                }
            };

            this.panelCache.addEventListener('mousedown', (e) => {
                const btn = e.target.closest('.action-btn');
                if (btn) {
                    const commandId = btn.id.replace('NiceFont_', '');
                    if (commandId === 'increase' || commandId === 'decrease') {
                        const command = this.getCommandsConfig().find(c => c.id === commandId);
                        if (command) {
                            startLongPress(command.action);
                        }
                    }
                }
            }, { capture: false });

            this.panelCache.addEventListener('mouseup', stopLongPress, { capture: false });
            this.panelCache.addEventListener('mouseleave', stopLongPress, { capture: false });

            // ç»‘å®šç‚¹å‡»äº‹ä»¶
            this.panelCache.addEventListener('click', (e) => {
                const btn = e.target.closest('.action-btn');
                if (btn) {
                    const command = this.getCommandsConfig().find(c => c.id === btn.id.replace('NiceFont_', ''));
                    if (command && command.id !== 'increase' && command.id !== 'decrease') {
                        log(`æ‰§è¡Œå‘½ä»¤: ${command.id}`);
                        command.action();
                    }
                }
                if (e.target.id === 'NiceFont_close-btn') {
                    this.panelCache.style.display = 'none';
                    this.overlayCache.style.display = 'none';
                    // æ£€æŸ¥æ˜¯å¦å› æ— é…ç½®è‡ªåŠ¨å¼¹å‡º
                    if (!ConfigScopeManager.hasConfig()) {
                        const now = Date.now();
                        const lastCloseTime = GM_getValue('NiceFont_lastCloseTime', 0);
                        let closeCount = GM_getValue('NiceFont_closeCount', 0);

                        if (now - lastCloseTime > CLOSE_TRACKING_WINDOW) {
                            // é‡ç½®è®¡æ•°ï¼ˆè¶…å‡ºæ—¶é—´çª—å£ï¼‰
                            closeCount = 0;
                            log('å…³é—­è®¡æ•°é‡ç½®ï¼ˆè¶…å‡ºæ—¶é—´çª—å£ï¼‰');
                        }

                        closeCount += 1;
                        GM_setValue('NiceFont_closeCount', closeCount);
                        GM_setValue('NiceFont_lastCloseTime', now);
                        log(`é¢æ¿å…³é—­ï¼ˆæ— é…ç½®æºï¼‰: closeCount=${closeCount}, lastCloseTime=${now}`);

                        if (closeCount >= CLOSE_COUNT_THRESHOLD) {
                            GM_setValue('NiceFont_autoOpenDisabled', true);
                            log('ç¦ç”¨æ— é…ç½®æºè‡ªåŠ¨å¼¹å‡ºï¼ˆè¿ç»­å…³é—­è¾¾åˆ°é˜ˆå€¼ï¼‰');
                        }
                    } else {
                        log('é¢æ¿å…³é—­ï¼ˆæœ‰é…ç½®æºï¼‰');
                    }
                }
                e.stopPropagation();
            }, { capture: false });
        },

        /**
         * æ›´æ–°é¢æ¿å†…å®¹
         */
        updatePanelContent() {
            if (!this.panelCache) return;
            const t = translations[State.get('currentLanguage')] || translations.en;
            const contentContainer = this.panelCache.querySelector('.NiceFont_content');
            if (contentContainer) {
                contentContainer.innerHTML = this.getCommandsConfig()
                    .filter(cmd => !cmd.tampermonkeyOnly)
                    .map(cmd =>
                        `<div class="action-btn" id="NiceFont_${cmd.id}">${cmd.getText()}</div>`
                    ).join('');
                log('é¢æ¿å†…å®¹æ›´æ–°æˆåŠŸ');
            } else {
                console.error('[NiceFont] æœªæ‰¾åˆ° .NiceFont_contentï¼Œæ— æ³•æ›´æ–°å†…å®¹');
            }
        },

        /**
         * æ›´æ–°æ²¹çŒ´èœå•
         */
        updateTampermonkeyMenu() {
            this.menuHandles.forEach(handle => {
                try {
                    GM_unregisterMenuCommand(handle);
                } catch (e) {
                    console.error('[NiceFont] å–æ¶ˆæ³¨å†Œèœå•å¤±è´¥:', e);
                }
            });
            this.menuHandles = [];
            const commands = State.get('panelType') === 'tampermonkey'
                ? this.getCommandsConfig().filter(cmd => cmd.id !== 'show-panel')
                : this.getCommandsConfig().filter(cmd => ['switch-panel', 'show-panel'].includes(cmd.id));
            commands.forEach(cmd => {
                const handle = GM_registerMenuCommand(cmd.getText(), () => {
                    cmd.action();
                    log(`æ‰§è¡Œæ²¹çŒ´èœå•å‘½ä»¤: ${cmd.id}`);
                }, { autoClose: cmd.autoClose });
                this.menuHandles.push(handle);
                log(`æ³¨å†Œèœå•: ${cmd.id}`);
            });
        },

        /**
         * æ˜¾ç¤º/éšè—é¢æ¿
         */
        togglePanel() {
            if (State.get('panelType') !== 'floating') return;
            const now = Date.now();
            if (now - this.lastToggleTime < 300) {
                log('togglePanel é˜²æŠ–ï¼Œå¿½ç•¥å¿«é€Ÿé‡å¤è°ƒç”¨');
                return;
            }
            this.lastToggleTime = now;
            if (!this.panelCache) {
                this.createFloatingPanel();
                if (this.panelCache) {
                    this.panelCache.style.display = 'block';
                    this.overlayCache.style.display = 'block';
                    log('é¢æ¿æ˜¾ç¤ºçŠ¶æ€: block (æ–°å»º)');
                }
            } else {
                const isHidden = this.panelCache.style.display === 'none';
                const display = isHidden ? 'block' : 'none';
                this.panelCache.style.display = display;
                this.overlayCache.style.display = display;
                log(`é¢æ¿æ˜¾ç¤ºçŠ¶æ€: ${display}`);
            }
        },

        /**
         * æ›´æ–°ç•Œé¢
         */
        updateUI() {
            log('è°ƒç”¨ updateUI, panelType:', State.get('panelType'));
            if (State.get('panelType') === 'tampermonkey') {
                this.updateTampermonkeyMenu();
                if (this.panelCache) {
                    this.panelCache.remove();
                    this.overlayCache.remove();
                    this.panelCache = null;
                    this.overlayCache = null;
                    log('ç§»é™¤æµ®åŠ¨é¢æ¿ï¼ˆåˆ‡æ¢åˆ°æ²¹çŒ´èœå•ï¼‰');
                }
            } else {
                this.updateTampermonkeyMenu();
                const hasConfig = ConfigScopeManager.hasConfig();
                const autoOpenDisabled = GM_getValue('NiceFont_autoOpenDisabled', false);
                if (!this.panelCache && !hasConfig && !autoOpenDisabled) {
                    this.createFloatingPanel();
                    if (this.panelCache) {
                        this.panelCache.style.display = 'block';
                        this.overlayCache.style.display = 'block';
                        log('è‡ªåŠ¨åˆ›å»ºå¹¶æ˜¾ç¤ºæµ®åŠ¨é¢æ¿ï¼ˆæ— é…ç½®ä¸”æœªç¦ç”¨è‡ªåŠ¨å¼¹å‡ºï¼‰');
                    }
                } else if (this.panelCache) {
                    this.updatePanelContent();
                    log('æ›´æ–°å·²æœ‰é¢æ¿å†…å®¹');
                } else {
                    log('è·³è¿‡è‡ªåŠ¨åˆ›å»ºé¢æ¿ï¼ˆå·²æœ‰é…ç½®ã€å·²ç¦ç”¨è‡ªåŠ¨å¼¹å‡ºæˆ–é¢æ¿å·²ç§»é™¤ï¼‰');
                }
                const t = translations[State.get('currentLanguage')] || translations.en;
                const saveBtn = this.panelCache?.querySelector('#NiceFont_save-config');
                if (saveBtn) {
                    saveBtn.textContent = `ğŸ’¾ ${State.get('isConfigModified') ? t.saveConfigPending : t.saveConfig}`;
                }
            }
        }
    };

    // --- å¤šè¯­è¨€æ”¯æŒ ---
    // æ”¯æŒçš„å¤šè¯­è¨€ï¼šæ±‰è¯­(zh)ã€è‹±è¯­(en)ã€éŸ©è¯­(ko)ã€æ—¥è¯­(ja)ã€ä¿„è¯­(ru)ã€æ³•è¯­(fr)ã€å¾·è¯­(de)ã€è¥¿ç­ç‰™è¯­(es)ã€è‘¡è„ç‰™è¯­(pt)
    const translations = {
        zh: {
            increase: 'å¢å¤§å­—ä½“',
            decrease: 'å‡å°å­—ä½“',
            reset: 'æ¢å¤å­—ä½“',
            fontSizeAdjustment: 'å­—ä½“å¤§å°è°ƒæ•´',
            setFontFamily: 'å­—ä½“ç±»å‹è°ƒæ•´',
            setFontFamilyPrompt: 'è¯·è¾“å…¥å­—ä½“ç±»å‹',
            supportFontFamily: 'æ”¯æŒçš„å­—ä½“ç±»å‹ï¼š',
            invalidFontFamilyAlert: 'è¯·è¾“å…¥æœ‰æ•ˆçš„å­—ä½“ç±»å‹ï¼',
            firstAdjustmentConfirm: 'è¯·è¾“å…¥é¦–æ¬¡è°ƒæ•´æ—¶é—´ï¼ˆç§’ï¼Œ0è¡¨ç¤ºç¦ç”¨ï¼‰ï¼š',
            firstAdjustmentEnabled: 'é¦–æ¬¡è°ƒæ•´å­—ä½“: âœ”ï¸',
            firstAdjustmentDisabled: 'é¦–æ¬¡è°ƒæ•´å­—ä½“: âœ–ï¸',
            timerPrompt: 'è¯·è¾“å…¥å®šæ—¶è°ƒæ•´é—´éš”ï¼ˆç§’ï¼Œ0è¡¨ç¤ºç¦ç”¨ï¼‰ï¼š',
            timerAdjustmentEnabled: 'å®šæ—¶è°ƒæ•´å­—ä½“: âœ”ï¸',
            timerAdjustmentDisabled: 'å®šæ—¶è°ƒæ•´å­—ä½“: âœ–ï¸',
            dynamicWatchConfirm: 'æ˜¯å¦å¯ç”¨/ç¦ç”¨åŠ¨æ€è°ƒæ•´ï¼Ÿ',
            dynamicAdjustmentEnabled: 'åŠ¨æ€è°ƒæ•´å­—ä½“: âœ”ï¸',
            dynamicAdjustmentDisabled: 'åŠ¨æ€è°ƒæ•´å­—ä½“: âœ–ï¸',
            usageLanguage: 'åˆ‡æ¢èœå•è¯­è¨€',
            switchPanel: 'åˆ‡æ¢èœå•é¢æ¿',
            tampermonkeyPanel: 'æ²¹çŒ´èœå•',
            floatingPanel: 'é¡µé¢èœå•',
            showPanel: 'æ˜¾ç¤ºé¢æ¿',
            configScope: 'é…ç½®ä½œç”¨èŒƒå›´',
            subdomain: 'å­åŸŸå',
            topLevelDomain: 'é¡¶çº§åŸŸå',
            allWebsites: 'æ‰€æœ‰ç½‘ç«™',
            configScopePrompt: 'è¯·è¾“å…¥é…ç½®ä½œç”¨èŒƒå›´ï¼š\n1: å­åŸŸå ({hostname})\n2: é¡¶çº§åŸŸå ({tld})\n3: æ‰€æœ‰ç½‘ç«™\nå½“å‰èŒƒå›´: {scope}',
            invalidInput: 'è¯·è¾“å…¥æœ‰æ•ˆçš„èŒƒå›´ï¼ˆ1, 2ï¼Œ æˆ– 3ï¼‰ï¼',
            currentConfigScope: 'å½“å‰é…ç½®æºäº',
            notConfigured: 'æœªé…ç½®',
            saveConfig: 'ä¿å­˜é…ç½®',
            saveConfigPending: 'ä¿å­˜é…ç½®ï¼ˆéœ€ç¡®å®šï¼‰',
            saveConfigConfirm: 'ç¡®å®šä¿å­˜é…ç½®åˆ°ï¼š{scope} [{target}]ï¼Ÿ',
            deleteConfigConfirm: 'ç¡®å®šåˆ é™¤å½“å‰é…ç½®å—ï¼Ÿï¼ˆå°†åˆ é™¤ï¼š{scope} [{target}]ï¼‰',
            deleteBeforeScopeChangeConfirm: 'æ›´æ”¹ä¸ºæ›´å¹¿çš„ä½œç”¨èŒƒå›´éœ€è¦å…ˆåˆ é™¤å½“å‰é…ç½®ã€‚\nç¡®å®šåˆ é™¤å½“å‰é…ç½®å—ï¼Ÿï¼ˆå°†åˆ é™¤ï¼š{scope} [{target}]ï¼‰'
        },
        en: {
            increase: 'Increase Font',
            decrease: 'Decrease Font',
            reset: 'Reset Font',
            fontSizeAdjustment: 'Font Size Adjustment',
            setFontFamily: 'Set Font Family',
            setFontFamilyPrompt: 'Enter font family',
            supportFontFamily: 'Supported font families:',
            invalidFontFamilyAlert: 'Please enter a valid font family!',
            firstAdjustmentConfirm: 'Enter first adjustment time (seconds, 0 to disable):',
            firstAdjustmentEnabled: 'First Font Adjustment: âœ”ï¸',
            firstAdjustmentDisabled: 'First Font Adjustment: âœ–ï¸',
            timerPrompt: 'Enter timer adjustment interval (seconds, 0 to disable):',
            timerAdjustmentEnabled: 'Timer Font Adjustment: âœ”ï¸',
            timerAdjustmentDisabled: 'Timer Font Adjustment: âœ–ï¸',
            dynamicWatchConfirm: 'Enable/Disable dynamic adjustment?',
            dynamicAdjustmentEnabled: 'Dynamic Font Adjustment: âœ”ï¸',
            dynamicAdjustmentDisabled: 'Dynamic Font Adjustment: âœ–ï¸',
            usageLanguage: 'Switch Menu Language',
            switchPanel: 'Switch Menu Panel',
            tampermonkeyPanel: 'Tampermonkey Menu',
            floatingPanel: 'Page Menu',
            showPanel: 'Show Panel',
            configScope: 'Config Scope',
            subdomain: 'Subdomain',
            topLevelDomain: 'Top-Level Domain',
            allWebsites: 'All Websites',
            configScopePrompt: 'Enter config scope:\n1: Subdomain ({hostname})\n2: Top-Level Domain ({tld})\n3: All Websites\nCurrent scope: {scope}',
            invalidInput: 'Please enter a valid scope (1, 2, or 3)!',
            currentConfigScope: 'Current Config Scope',
            notConfigured: 'Not Configured',
            saveConfig: 'Save Config',
            saveConfigPending: 'Save Config (Pending)',
            saveConfigConfirm: 'Save configuration to: {scope} [{target}]?',
            deleteConfigConfirm: 'Are you sure to delete the current configuration? (Will delete: {scope} [{target}])',
            deleteBeforeScopeChangeConfirm: 'Changing to a broader scope requires deleting the current configuration.\nAre you sure to delete the current configuration? (Will delete: {scope} [{target}])'
        },
        ko: {
            increase: 'ê¸€ê¼´ í™•ëŒ€',
            decrease: 'ê¸€ê¼´ ì¶•ì†Œ',
            reset: 'ê¸€ê¼´ ì´ˆê¸°í™”',
            fontSizeAdjustment: 'ê¸€ê¼´ í¬ê¸° ì¡°ì •',
            setFontFamily: 'ê¸€ê¼´ ì„¤ì •',
            setFontFamilyPrompt: 'ê¸€ê¼´ì„ ì…ë ¥í•˜ì„¸ìš”',
            supportFontFamily: 'ì§€ì›ë˜ëŠ” ê¸€ê¼´:',
            invalidFontFamilyAlert: 'ìœ íš¨í•œ ê¸€ê¼´ì„ ì…ë ¥í•˜ì„¸ìš”!',
            firstAdjustmentConfirm: 'ì²« ì¡°ì • ì‹œê°„ ì…ë ¥ (ì´ˆ, 0ì€ ë¹„í™œì„±í™”):',
            firstAdjustmentEnabled: 'ì²« ê¸€ê¼´ ì¡°ì •: âœ”ï¸',
            firstAdjustmentDisabled: 'ì²« ê¸€ê¼´ ì¡°ì •: âœ–ï¸',
            timerPrompt: 'íƒ€ì´ë¨¸ ì¡°ì • ê°„ê²© ì…ë ¥ (ì´ˆ, 0ì€ ë¹„í™œì„±í™”):',
            timerAdjustmentEnabled: 'íƒ€ì´ë¨¸ ê¸€ê¼´ ì¡°ì •: âœ”ï¸',
            timerAdjustmentDisabled: 'íƒ€ì´ë¨¸ ê¸€ê¼´ ì¡°ì •: âœ–ï¸',
            dynamicWatchConfirm: 'ë™ì  ì¡°ì •ì„ í™œì„±í™”/ë¹„í™œì„±í™” í•˜ì‹œê² ìŠµë‹ˆê¹Œ?',
            dynamicAdjustmentEnabled: 'ë™ì  ê¸€ê¼´ ì¡°ì •: âœ”ï¸',
            dynamicAdjustmentDisabled: 'ë™ì  ê¸€ê¼´ ì¡°ì •: âœ–ï¸',
            usageLanguage: 'ë©”ë‰´ ì–¸ì–´ ì „í™˜',
            switchPanel: 'ë©”ë‰´ íŒ¨ë„ ì „í™˜',
            tampermonkeyPanel: 'íƒ¬í¼ëª½í‚¤ ë©”ë‰´',
            floatingPanel: 'í˜ì´ì§€ ë©”ë‰´',
            showPanel: 'íŒ¨ë„ í‘œì‹œ',
            configScope: 'ì„¤ì • ë²”ìœ„',
            subdomain: 'ì„œë¸Œë„ë©”ì¸',
            topLevelDomain: 'ìµœìƒìœ„ ë„ë©”ì¸',
            allWebsites: 'ëª¨ë“  ì›¹ì‚¬ì´íŠ¸',
            configScopePrompt: 'ì„¤ì • ë²”ìœ„ë¥¼ ì…ë ¥í•˜ì„¸ìš”:\n1: ì„œë¸Œë„ë©”ì¸ ({hostname})\n2: ìµœìƒìœ„ ë„ë©”ì¸ ({tld})\n3: ëª¨ë“  ì›¹ì‚¬ì´íŠ¸\ní˜„ì¬ ë²”ìœ„: {scope}',
            invalidInput: 'ìœ íš¨í•œ ë²”ìœ„ë¥¼ ì…ë ¥í•˜ì„¸ìš” (1, 2, ë˜ëŠ” 3)!',
            currentConfigScope: 'í˜„ì¬ ì„¤ì • ë²”ìœ„',
            notConfigured: 'ì„¤ì •ë˜ì§€ ì•ŠìŒ',
            saveConfig: 'ì„¤ì • ì €ì¥',
            saveConfigPending: 'ì„¤ì • ì €ì¥ (í™•ì¸ í•„ìš”)',
            saveConfigConfirm: 'ì„¤ì •ì„ ë‹¤ìŒì— ì €ì¥í•˜ì‹œê² ìŠµë‹ˆê¹Œ: {scope} [{target}]?',
            deleteConfigConfirm: 'í˜„ì¬ ì„¤ì •ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ì‚­ì œë  í•­ëª©: {scope} [{target}])',
            deleteBeforeScopeChangeConfirm: 'ë” ë„“ì€ ë²”ìœ„ë¡œ ë³€ê²½í•˜ë ¤ë©´ í˜„ì¬ ì„¤ì •ì„ ì‚­ì œí•´ì•¼ í•©ë‹ˆë‹¤.\ní˜„ì¬ ì„¤ì •ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ì‚­ì œë  í•­ëª©: {scope} [{target}])'
        },
        ja: {
            increase: 'ãƒ•ã‚©ãƒ³ãƒˆã‚’å¤§ããã™ã‚‹',
            decrease: 'ãƒ•ã‚©ãƒ³ãƒˆã‚’å°ã•ãã™ã‚‹',
            reset: 'ãƒ•ã‚©ãƒ³ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ',
            fontSizeAdjustment: 'ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºèª¿æ•´',
            setFontFamily: 'ãƒ•ã‚©ãƒ³ãƒˆãƒ•ã‚¡ãƒŸãƒªãƒ¼è¨­å®š',
            setFontFamilyPrompt: 'ãƒ•ã‚©ãƒ³ãƒˆãƒ•ã‚¡ãƒŸãƒªãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„',
            supportFontFamily: 'ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ãƒ•ã‚©ãƒ³ãƒˆãƒ•ã‚¡ãƒŸãƒªãƒ¼ï¼š',
            invalidFontFamilyAlert: 'æœ‰åŠ¹ãªãƒ•ã‚©ãƒ³ãƒˆãƒ•ã‚¡ãƒŸãƒªãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼',
            firstAdjustmentConfirm: 'åˆå›èª¿æ•´æ™‚é–“ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆç§’ã€0ã§ç„¡åŠ¹ï¼‰ï¼š',
            firstAdjustmentEnabled: 'åˆå›ãƒ•ã‚©ãƒ³ãƒˆèª¿æ•´ï¼šâœ”ï¸',
            firstAdjustmentDisabled: 'åˆå›ãƒ•ã‚©ãƒ³ãƒˆèª¿æ•´ï¼šâœ–ï¸',
            timerPrompt: 'ã‚¿ã‚¤ãƒãƒ¼èª¿æ•´é–“éš”ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆç§’ã€0ã§ç„¡åŠ¹ï¼‰ï¼š',
            timerAdjustmentEnabled: 'ã‚¿ã‚¤ãƒãƒ¼ãƒ•ã‚©ãƒ³ãƒˆèª¿æ•´ï¼šâœ”ï¸',
            timerAdjustmentDisabled: 'ã‚¿ã‚¤ãƒãƒ¼ãƒ•ã‚©ãƒ³ãƒˆèª¿æ•´ï¼šâœ–ï¸',
            dynamicWatchConfirm: 'å‹•çš„èª¿æ•´ã‚’æœ‰åŠ¹/ç„¡åŠ¹ã«ã—ã¾ã™ã‹ï¼Ÿ',
            dynamicAdjustmentEnabled: 'å‹•çš„ãƒ•ã‚©ãƒ³ãƒˆèª¿æ•´ï¼šâœ”ï¸',
            dynamicAdjustmentDisabled: 'å‹•çš„ãƒ•ã‚©ãƒ³ãƒˆèª¿æ•´ï¼šâœ–ï¸',
            usageLanguage: 'ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¨€èªã®åˆ‡ã‚Šæ›¿ãˆ',
            switchPanel: 'ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒ‘ãƒãƒ«ã®åˆ‡ã‚Šæ›¿ãˆ',
            tampermonkeyPanel: 'Tampermonkeyãƒ¡ãƒ‹ãƒ¥ãƒ¼',
            floatingPanel: 'ãƒšãƒ¼ã‚¸ãƒ¡ãƒ‹ãƒ¥ãƒ¼',
            showPanel: 'ãƒ‘ãƒãƒ«ã‚’è¡¨ç¤º',
            configScope: 'è¨­å®šç¯„å›²',
            subdomain: 'ã‚µãƒ–ãƒ‰ãƒ¡ã‚¤ãƒ³',
            topLevelDomain: 'ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ãƒ‰ãƒ¡ã‚¤ãƒ³',
            allWebsites: 'ã™ã¹ã¦ã®ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆ',
            configScopePrompt: 'è¨­å®šç¯„å›²ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼š\n1: ã‚µãƒ–ãƒ‰ãƒ¡ã‚¤ãƒ³ ({hostname})\n2: ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ãƒ‰ãƒ¡ã‚¤ãƒ³ ({tld})\n3: ã™ã¹ã¦ã®ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆ\nç¾åœ¨ã®ç¯„å›²: {scope}',
            invalidInput: 'æœ‰åŠ¹ãªç¯„å›²ï¼ˆ1ã€2ã€ã¾ãŸã¯3ï¼‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼',
            currentConfigScope: 'ç¾åœ¨ã®è¨­å®šç¯„å›²',
            notConfigured: 'æœªè¨­å®š',
            saveConfig: 'è¨­å®šã‚’ä¿å­˜',
            saveConfigPending: 'è¨­å®šã‚’ä¿å­˜ï¼ˆç¢ºèªãŒå¿…è¦ï¼‰',
            saveConfigConfirm: 'è¨­å®šã‚’ä¿å­˜ã—ã¾ã™ã‹ï¼š{scope} [{target}]ï¼Ÿ',
            deleteConfigConfirm: 'ç¾åœ¨ã®è¨­å®šã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿï¼ˆå‰Šé™¤å¯¾è±¡ï¼š{scope} [{target}]ï¼‰',
            deleteBeforeScopeChangeConfirm: 'ã‚ˆã‚Šåºƒã„ç¯„å›²ã«å¤‰æ›´ã™ã‚‹ã«ã¯ã€ç¾åœ¨ã®è¨­å®šã‚’å‰Šé™¤ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚\nç¾åœ¨ã®è¨­å®šã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿï¼ˆå‰Šé™¤å¯¾è±¡ï¼š{scope} [{target}]ï¼‰'
        },
        ru: {
            increase: 'Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ñ‚ÑŒ ÑˆÑ€Ğ¸Ñ„Ñ‚',
            decrease: 'Ğ£Ğ¼ĞµĞ½ÑŒÑˆĞ¸Ñ‚ÑŒ ÑˆÑ€Ğ¸Ñ„Ñ‚',
            reset: 'Ğ¡Ğ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ ÑˆÑ€Ğ¸Ñ„Ñ‚',
            fontSizeAdjustment: 'Ğ ĞµĞ³ÑƒĞ»Ğ¸Ñ€Ğ¾Ğ²ĞºĞ° Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ° ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ°',
            setFontFamily: 'Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ ÑĞµĞ¼ĞµĞ¹ÑÑ‚Ğ²Ğ¾ ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ¾Ğ²',
            setFontFamilyPrompt: 'Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ÑĞµĞ¼ĞµĞ¹ÑÑ‚Ğ²Ğ¾ ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ¾Ğ²',
            supportFontFamily: 'ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµĞ¼Ñ‹Ğµ ÑĞµĞ¼ĞµĞ¹ÑÑ‚Ğ²Ğ° ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ¾Ğ²:',
            invalidFontFamilyAlert: 'ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğµ ÑĞµĞ¼ĞµĞ¹ÑÑ‚Ğ²Ğ¾ ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ¾Ğ²!',
            firstAdjustmentConfirm: 'Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ²Ñ€ĞµĞ¼Ñ Ğ¿ĞµÑ€Ğ²Ğ¾Ğ¹ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ (ÑĞµĞºÑƒĞ½Ğ´Ñ‹, 0 Ğ´Ğ»Ñ Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ):',
            firstAdjustmentEnabled: 'ĞŸĞµÑ€Ğ²Ğ°Ñ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ°: âœ”ï¸',
            firstAdjustmentDisabled: 'ĞŸĞµÑ€Ğ²Ğ°Ñ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ°: âœ–ï¸',
            timerPrompt: 'Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ» Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€Ğ° Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ (ÑĞµĞºÑƒĞ½Ğ´Ñ‹, 0 Ğ´Ğ»Ñ Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ):',
            timerAdjustmentEnabled: 'ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ° Ğ¿Ğ¾ Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€Ñƒ: âœ”ï¸',
            timerAdjustmentDisabled: 'ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ° Ğ¿Ğ¾ Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€Ñƒ: âœ–ï¸',
            dynamicWatchConfirm: 'Ğ’ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ/Ğ¾Ñ‚ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ´Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºÑƒÑ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºÑƒ?',
            dynamicAdjustmentEnabled: 'Ğ”Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ°: âœ”ï¸',
            dynamicAdjustmentDisabled: 'Ğ”Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ°: âœ–ï¸',
            usageLanguage: 'ĞŸĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ ÑĞ·Ñ‹Ğº Ğ¼ĞµĞ½Ñ',
            switchPanel: 'ĞŸĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ Ğ¼ĞµĞ½Ñ',
            tampermonkeyPanel: 'ĞœĞµĞ½Ñ Tampermonkey',
            floatingPanel: 'ĞœĞµĞ½Ñ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ñ‹',
            showPanel: 'ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ',
            configScope: 'ĞĞ±Ğ»Ğ°ÑÑ‚ÑŒ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ğ¸',
            subdomain: 'Ğ¡ÑƒĞ±Ğ´Ğ¾Ğ¼ĞµĞ½',
            topLevelDomain: 'Ğ”Ğ¾Ğ¼ĞµĞ½ Ğ²ĞµÑ€Ñ…Ğ½ĞµĞ³Ğ¾ ÑƒÑ€Ğ¾Ğ²Ğ½Ñ',
            allWebsites: 'Ğ’ÑĞµ Ğ²ĞµĞ±-ÑĞ°Ğ¹Ñ‚Ñ‹',
            configScopePrompt: 'Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ğ¸:\n1: Ğ¡ÑƒĞ±Ğ´Ğ¾Ğ¼ĞµĞ½ ({hostname})\n2: Ğ”Ğ¾Ğ¼ĞµĞ½ Ğ²ĞµÑ€Ñ…Ğ½ĞµĞ³Ğ¾ ÑƒÑ€Ğ¾Ğ²Ğ½Ñ ({tld})\n3: Ğ’ÑĞµ Ğ²ĞµĞ±-ÑĞ°Ğ¹Ñ‚Ñ‹\nĞ¢ĞµĞºÑƒÑ‰Ğ°Ñ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ: {scope}',
            invalidInput: 'ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ‚ĞµĞ»ÑŒĞ½ÑƒÑ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ (1, 2 Ğ¸Ğ»Ğ¸ 3)!',
            currentConfigScope: 'Ğ¢ĞµĞºÑƒÑ‰Ğ°Ñ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ğ¸',
            notConfigured: 'ĞĞµ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ¾',
            saveConfig: 'Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ',
            saveConfigPending: 'Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ (Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµÑ‚ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ)',
            saveConfigConfirm: 'Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ Ğ²: {scope} [{target}]?',
            deleteConfigConfirm: 'Ğ’Ñ‹ ÑƒĞ²ĞµÑ€ĞµĞ½Ñ‹, Ñ‡Ñ‚Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ? (Ğ‘ÑƒĞ´ĞµÑ‚ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¾: {scope} [{target}])',
            deleteBeforeScopeChangeConfirm: 'Ğ”Ğ»Ñ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ Ğ½Ğ° Ğ±Ğ¾Ğ»ĞµĞµ ÑˆĞ¸Ñ€Ğ¾ĞºÑƒÑ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ.\nĞ’Ñ‹ ÑƒĞ²ĞµÑ€ĞµĞ½Ñ‹, Ñ‡Ñ‚Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ? (Ğ‘ÑƒĞ´ĞµÑ‚ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¾: {scope} [{target}])'
        },
        fr: {
            increase: 'Augmenter la police',
            decrease: 'RÃ©duire la police',
            reset: 'RÃ©initialiser la police',
            fontSizeAdjustment: 'Ajustement de la taille de la police',
            setFontFamily: 'DÃ©finir la famille de polices',
            setFontFamilyPrompt: 'Entrez la famille de polices',
            supportFontFamily: 'Familles de polices prises en charge :',
            invalidFontFamilyAlert: 'Veuillez entrer une famille de polices valide !',
            firstAdjustmentConfirm: 'Entrez le temps du premier ajustement (secondes, 0 pour dÃ©sactiver) :',
            firstAdjustmentEnabled: 'Premier ajustement de police : âœ”ï¸',
            firstAdjustmentDisabled: 'Premier ajustement de police : âœ–ï¸',
            timerPrompt: 'Entrez lâ€™intervalle dâ€™ajustement du minuteur (secondes, 0 pour dÃ©sactiver) :',
            timerAdjustmentEnabled: 'Ajustement de police par minuteur : âœ”ï¸',
            timerAdjustmentDisabled: 'Ajustement de police par minuteur : âœ–ï¸',
            dynamicWatchConfirm: 'Activer/dÃ©sactiver lâ€™ajustement dynamique ?',
            dynamicAdjustmentEnabled: 'Ajustement dynamique de la police : âœ”ï¸',
            dynamicAdjustmentDisabled: 'Ajustement dynamique de la police : âœ–ï¸',
            usageLanguage: 'Changer la langue du menu',
            switchPanel: 'Changer de panneau de menu',
            tampermonkeyPanel: 'Menu Tampermonkey',
            floatingPanel: 'Menu de la page',
            showPanel: 'Afficher le panneau',
            configScope: 'PortÃ©e de la configuration',
            subdomain: 'Sous-domaine',
            topLevelDomain: 'Domaine de premier niveau',
            allWebsites: 'Tous les sites web',
            configScopePrompt: 'Entrez la portÃ©e de la configuration :\n1 : Sous-domaine ({hostname})\n2 : Domaine de premier niveau ({tld})\n3 : Tous les sites web\nPortÃ©e actuelle : {scope}',
            invalidInput: 'Veuillez entrer une portÃ©e valide (1, 2 ou 3) !',
            currentConfigScope: 'PortÃ©e de configuration actuelle',
            notConfigured: 'Non configurÃ©',
            saveConfig: 'Enregistrer la configuration',
            saveConfigPending: 'Enregistrer la configuration (en attente)',
            saveConfigConfirm: 'Enregistrer la configuration dans : {scope} [{target}] ?',
            deleteConfigConfirm: 'ÃŠtes-vous sÃ»r de vouloir supprimer la configuration actuelle ? (Supprimera : {scope} [{target}])',
            deleteBeforeScopeChangeConfirm: 'Changer pour une portÃ©e plus large nÃ©cessite de supprimer la configuration actuelle.\nÃŠtes-vous sÃ»r de vouloir supprimer la configuration actuelle ? (Supprimera : {scope} [{target}])'
        },
        de: {
            increase: 'Schriftart vergrÃ¶ÃŸern',
            decrease: 'Schriftart verkleinern',
            reset: 'Schriftart zurÃ¼cksetzen',
            fontSizeAdjustment: 'SchriftgrÃ¶ÃŸenanpassung',
            setFontFamily: 'Schriftfamilie festlegen',
            setFontFamilyPrompt: 'Geben Sie die Schriftfamilie ein',
            supportFontFamily: 'UnterstÃ¼tzte Schriftfamilien:',
            invalidFontFamilyAlert: 'Bitte geben Sie eine gÃ¼ltige Schriftfamilie ein!',
            firstAdjustmentConfirm: 'Geben Sie die Zeit fÃ¼r die erste Anpassung ein (Sekunden, 0 zum Deaktivieren):',
            firstAdjustmentEnabled: 'Erste Schrifteinstellung: âœ”ï¸',
            firstAdjustmentDisabled: 'Erste Schrifteinstellung: âœ–ï¸',
            timerPrompt: 'Geben Sie das Intervall fÃ¼r die Timer-Anpassung ein (Sekunden, 0 zum Deaktivieren):',
            timerAdjustmentEnabled: 'Timer-Schrifteinstellung: âœ”ï¸',
            timerAdjustmentDisabled: 'Timer-Schrifteinstellung: âœ–ï¸',
            dynamicWatchConfirm: 'Dynamische Anpassung aktivieren/deaktivieren?',
            dynamicAdjustmentEnabled: 'Dynamische Schrifteinstellung: âœ”ï¸',
            dynamicAdjustmentDisabled: 'Dynamische Schrifteinstellung: âœ–ï¸',
            usageLanguage: 'MenÃ¼sprache wechseln',
            switchPanel: 'MenÃ¼panel wechseln',
            tampermonkeyPanel: 'Tampermonkey-MenÃ¼',
            floatingPanel: 'SeitenmenÃ¼',
            showPanel: 'Panel anzeigen',
            configScope: 'Konfigurationsbereich',
            subdomain: 'Subdomain',
            topLevelDomain: 'Top-Level-Domain',
            allWebsites: 'Alle Websites',
            configScopePrompt: 'Geben Sie den Konfigurationsbereich ein:\n1: Subdomain ({hostname})\n2: Top-Level-Domain ({tld})\n3: Alle Websites\nAktueller Bereich: {scope}',
            invalidInput: 'Bitte geben Sie einen gÃ¼ltigen Bereich ein (1, 2 oder 3)!',
            currentConfigScope: 'Aktueller Konfigurationsbereich',
            notConfigured: 'Nicht konfiguriert',
            saveConfig: 'Konfiguration speichern',
            saveConfigPending: 'Konfiguration speichern (ausstehend)',
            saveConfigConfirm: 'Konfiguration speichern in: {scope} [{target}]?',
            deleteConfigConfirm: 'MÃ¶chten Sie die aktuelle Konfiguration wirklich lÃ¶schen? (Wird gelÃ¶scht: {scope} [{target}])',
            deleteBeforeScopeChangeConfirm: 'Zum Wechseln zu einem breiteren Bereich muss die aktuelle Konfiguration gelÃ¶scht werden.\nMÃ¶chten Sie die aktuelle Konfiguration wirklich lÃ¶schen? (Wird gelÃ¶scht: {scope} [{target}])'
        },
        es: {
            increase: 'Aumentar fuente',
            decrease: 'Reducir fuente',
            reset: 'Restablecer fuente',
            fontSizeAdjustment: 'Ajuste del tamaÃ±o de fuente',
            setFontFamily: 'Establecer familia de fuentes',
            setFontFamilyPrompt: 'Ingrese la familia de fuentes',
            supportFontFamily: 'Familias de fuentes compatibles:',
            invalidFontFamilyAlert: 'Â¡Por favor, ingrese una familia de fuentes vÃ¡lida!',
            firstAdjustmentConfirm: 'Ingrese el tiempo del primer ajuste (segundos, 0 para desactivar):',
            firstAdjustmentEnabled: 'Primer ajuste de fuente: âœ”ï¸',
            firstAdjustmentDisabled: 'Primer ajuste de fuente: âœ–ï¸',
            timerPrompt: 'Ingrese el intervalo de ajuste del temporizador (segundos, 0 para desactivar):',
            timerAdjustmentEnabled: 'Ajuste de fuente por temporizador: âœ”ï¸',
            timerAdjustmentDisabled: 'Ajuste de fuente por temporizador: âœ–ï¸',
            dynamicWatchConfirm: 'Â¿Activar/desactivar el ajuste dinÃ¡mico?',
            dynamicAdjustmentEnabled: 'Ajuste dinÃ¡mico de fuente: âœ”ï¸',
            dynamicAdjustmentDisabled: 'Ajuste dinÃ¡mico de fuente: âœ–ï¸',
            usageLanguage: 'Cambiar idioma del menÃº',
            switchPanel: 'Cambiar panel del menÃº',
            tampermonkeyPanel: 'MenÃº de Tampermonkey',
            floatingPanel: 'MenÃº de pÃ¡gina',
            showPanel: 'Mostrar panel',
            configScope: 'Alcance de la configuraciÃ³n',
            subdomain: 'Subdominio',
            topLevelDomain: 'Dominio de nivel superior',
            allWebsites: 'Todos los sitios web',
            configScopePrompt: 'Ingrese el alcance de la configuraciÃ³n:\n1: Subdominio ({hostname})\n2: Dominio de nivel superior ({tld})\n3: Todos los sitios web\nAlcance actual: {scope}',
            invalidInput: 'Â¡Por favor, ingrese un alcance vÃ¡lido (1, 2 o 3)!',
            currentConfigScope: 'Alcance de configuraciÃ³n actual',
            notConfigured: 'No configurado',
            saveConfig: 'Guardar configuraciÃ³n',
            saveConfigPending: 'Guardar configuraciÃ³n (pendiente)',
            saveConfigConfirm: 'Â¿Guardar configuraciÃ³n en: {scope} [{target}]?',
            deleteConfigConfirm: 'Â¿EstÃ¡ seguro de que desea eliminar la configuraciÃ³n actual? (Se eliminarÃ¡: {scope} [{target}])',
            deleteBeforeScopeChangeConfirm: 'Cambiar a un alcance mÃ¡s amplio requiere eliminar la configuraciÃ³n actual.\nÂ¿EstÃ¡ seguro de que desea eliminar la configuraciÃ³n actual? (Se eliminarÃ¡: {scope} [{target}])'
        },
        pt: {
            increase: 'Aumentar fonte',
            decrease: 'Diminuir fonte',
            reset: 'Redefinir fonte',
            fontSizeAdjustment: 'Ajuste do tamanho da fonte',
            setFontFamily: 'Definir famÃ­lia de fontes',
            setFontFamilyPrompt: 'Digite a famÃ­lia de fontes',
            supportFontFamily: 'FamÃ­lias de fontes suportadas:',
            invalidFontFamilyAlert: 'Por favor, insira uma famÃ­lia de fontes vÃ¡lida!',
            firstAdjustmentConfirm: 'Digite o tempo do primeiro ajuste (segundos, 0 para desativar):',
            firstAdjustmentEnabled: 'Primeiro ajuste de fonte: âœ”ï¸',
            firstAdjustmentDisabled: 'Primeiro ajuste de fonte: âœ–ï¸',
            timerPrompt: 'Digite o intervalo de ajuste do temporizador (segundos, 0 para desativar):',
            timerAdjustmentEnabled: 'Ajuste de fonte por temporizador: âœ”ï¸',
            timerAdjustmentDisabled: 'Ajuste de fonte por temporizador: âœ–ï¸',
            dynamicWatchConfirm: 'Ativar/desativar ajuste dinÃ¢mico?',
            dynamicAdjustmentEnabled: 'Ajuste dinÃ¢mico de fonte: âœ”ï¸',
            dynamicAdjustmentDisabled: 'Ajuste dinÃ¢mico de fonte: âœ–ï¸',
            usageLanguage: 'Mudar idioma do menu',
            switchPanel: 'Mudar painel do menu',
            tampermonkeyPanel: 'Menu Tampermonkey',
            floatingPanel: 'Menu da pÃ¡gina',
            showPanel: 'Mostrar painel',
            configScope: 'Escopo da configuraÃ§Ã£o',
            subdomain: 'SubdomÃ­nio',
            topLevelDomain: 'DomÃ­nio de nÃ­vel superior',
            allWebsites: 'Todos os sites',
            configScopePrompt: 'Digite o escopo da configuraÃ§Ã£o:\n1: SubdomÃ­nio ({hostname})\n2: DomÃ­nio de nÃ­vel superior ({tld})\n3: Todos os sites\nEscopo atual: {scope}',
            invalidInput: 'Por favor, insira um escopo vÃ¡lido (1, 2 ou 3)!',
            currentConfigScope: 'Escopo de configuraÃ§Ã£o atual',
            notConfigured: 'NÃ£o configurado',
            saveConfig: 'Salvar configuraÃ§Ã£o',
            saveConfigPending: 'Salvar configuraÃ§Ã£o (pendente)',
            saveConfigConfirm: 'Salvar configuraÃ§Ã£o em: {scope} [{target}]?',
            deleteConfigConfirm: 'Tem certeza de que deseja excluir a configuraÃ§Ã£o atual? (SerÃ¡ excluÃ­do: {scope} [{target}])',
            deleteBeforeScopeChangeConfirm: 'Mudar para um escopo mais amplo exige a exclusÃ£o da configuraÃ§Ã£o atual.\nTem certeza de que deseja excluir a configuraÃ§Ã£o atual? (SerÃ¡ excluÃ­do: {scope} [{target}])'
        }
    };

    // --- CSS æ ·å¼ ---
    GM_addStyle(`
        :root {
            --nicefont-family: none;
        }
        *:not(#NiceFont_panel):not([data-nicefont-panel]):not(#NiceFont_panel *) {
            font-family: var(--nicefont-family, inherit) !important;
        }
        #NiceFont_panel {
            position: fixed;
            width: 300px;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 10001;
            font-family: sans-serif !important;
            font-size: 15px;
            user-select: none;
        }
        #NiceFont_panel .NiceFont_header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
            z-index: 10002;
        }
        #NiceFont_panel .NiceFont_header > div {
            font-size: 16px !important;
            font-family: sans-serif !important;
            text-align: left;
            flex-grow: 1;
            cursor: grab;
            margin: 5px;
            font-weight: bold;
        }
        #NiceFont_panel .NiceFont_close-btn {
            border: none;
            border-radius: 3px;
            padding: 1px 6px;
            cursor: pointer;
            line-height: 16px;
            font-size: 12px;
            background: none;
            color: #000;
        }
        #NiceFont_panel .NiceFont_close-btn:hover {
            text-decoration: underline;
        }
        #NiceFont_panel .action-btn {
            display: block;
            padding: 2px;
            border-radius: 3px;
            cursor: pointer;
            text-align: left;
        }
        #NiceFont_panel .action-btn:hover {
            text-decoration: underline;
        }
        #NiceFont_panel #NiceFont_set-font-size-btn {
            padding: 2px;
            text-decoration: none !important;
        }
        #NiceFont_panel .font-family-select {
            display: inline-block;
            width: auto;
            padding: 2px;
            margin-left: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 14px;
            vertical-align: middle;
        }
    `);

    // --- åˆå§‹åŒ– ---
    /**
     * åˆå§‹åŒ–è„šæœ¬
     */
    function init() {
        // åˆå§‹åŒ–è¯­è¨€
        let lang = GM_getValue('language', navigator.language);
        if (!translations[lang]) {
            lang = lang.startsWith('zh') ? 'zh' : 'en';
            GM_setValue('language', lang);
        }
        State.set('currentLanguage', lang);
        log(`è¯­è¨€è®¾ç½®ä¸º: ${lang}`);

        // åˆå§‹åŒ–é¢æ¿ç±»å‹
        let panelType = GM_getValue(ConfigScopeManager.PANEL_TYPE_KEY, 'floating');
        State.set('panelType', panelType);
        log(`é¢æ¿ç±»å‹è®¾ç½®ä¸º: ${panelType}`);

        // åŠ è½½é…ç½®
        ConfigManager.loadConfig();

        // åˆå§‹åŒ–ç•Œé¢
        UIManager.updateUI();

        // åˆå§‹åŒ–å­—ä½“è°ƒæ•´
        window.addEventListener('load', () => {
            if (State.get('currentAdjustment') !== 0 || State.get('currentFontFamily') !== 'none') {
                if (State.get('firstAdjustment') && State.get('firstAdjustmentTime') > 0) {
                    setTimeout(() => {
                        FontManager.applyFontRecursively(document.body, State.get('currentAdjustment'));
                        log('åº”ç”¨é¦–æ¬¡å­—ä½“è°ƒæ•´');
                    }, State.get('firstAdjustmentTime') * 1000);
                }
                if (State.get('watchDOMChanges')) {
                    if (State.get('timer')) clearInterval(State.get('timer'));
                    const nodeCount = document.body.getElementsByTagName('*').length;
                    const throttleTime = nodeCount > 10000 ? 200 : 100;
                    State.set('observer', new MutationObserver(Utils.throttle(() => {
                        FontManager.applyFontRecursively(document.body, State.get('currentAdjustment'));
                    }, throttleTime)));
                    State.get('observer').observe(document.body, { childList: true, subtree: true });
                    log('åŠ¨æ€è°ƒæ•´å¯ç”¨');
                } else if (State.get('intervalSeconds') > 0) {
                    if (State.get('observer')) State.get('observer').disconnect();
                    State.set('timer', setInterval(() => {
                        FontManager.applyFontRecursively(document.body, State.get('currentAdjustment'));
                    }, State.get('intervalSeconds') * 1000));
                    log(`å®šæ—¶è°ƒæ•´å¯ç”¨: ${State.get('intervalSeconds')}s`);
                }
            }
        });

        log('è„šæœ¬åˆå§‹åŒ–å®Œæˆ');
    }

    init();
})();